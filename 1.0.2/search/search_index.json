{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAPI Guard Agent","text":"<p> FastAPI Guard Agent is a sophisticated telemetry and monitoring solution designed to provide comprehensive security intelligence for FastAPI applications. Built as a companion to FastAPI Guard, it enables real-time collection of security events, performance metrics, and operational telemetry, facilitating centralized security operations, compliance reporting, and dynamic threat response through an enterprise-grade management platform. </p> <p> </p> <p> </p> <p> </p> <p>The FastAPI Guard Agent represents a critical component in modern application security architecture. As organizations increasingly adopt microservices and API-driven architectures, the need for sophisticated security telemetry has become paramount. This agent bridges the gap between application-level security enforcement and enterprise security operations, providing real-time visibility into security events, performance anomalies, and threat patterns across your FastAPI infrastructure.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>The FastAPI Guard Agent is engineered for seamless integration with your existing security infrastructure. The following example demonstrates the standard deployment pattern:</p> <pre><code>from fastapi import FastAPI\nfrom guard import SecurityConfig, SecurityMiddleware\n\napp = FastAPI()\n\n# Configure FastAPI Guard with built-in agent support\nconfig = SecurityConfig(\n    # Basic security settings\n    auto_ban_threshold=5,\n    auto_ban_duration=300,\n\n    # Enable agent for telemetry\n    enable_agent=True,\n    agent_api_key=\"YOUR_API_KEY\",\n    agent_project_id=\"YOUR_PROJECT_ID\",\n    agent_endpoint=\"https://api.fastapi-guard.com\",\n\n    # Agent configuration\n    agent_buffer_size=100,\n    agent_flush_interval=30,\n    agent_enable_events=True,\n    agent_enable_metrics=True,\n\n    # Enable dynamic rules from SaaS\n    enable_dynamic_rules=True,\n    dynamic_rule_interval=300,\n)\n\n# Add security middleware - events are sent automatically\nmiddleware = SecurityMiddleware(app, config=config)\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n</code></pre>"},{"location":"#core-capabilities","title":"Core Capabilities","text":""},{"location":"#security-intelligence","title":"Security Intelligence","text":"<ul> <li>Automated Event Collection: Captures comprehensive security events including authentication failures, authorization violations, rate limit breaches, and suspicious request patterns without manual instrumentation</li> <li>Real-Time Threat Detection: Provides immediate visibility into security incidents with sub-second event propagation to the management platform</li> <li>Behavioral Analytics: Tracks request patterns and user behavior to identify anomalies and potential security threats</li> </ul>"},{"location":"#enterprise-architecture","title":"Enterprise Architecture","text":"<ul> <li>Zero-Impact Performance: Leverages asynchronous I/O and intelligent buffering to ensure telemetry collection adds negligible overhead to application performance</li> <li>Fault-Tolerant Design: Implements circuit breakers, exponential backoff with jitter, and intelligent retry mechanisms to maintain operation during network disruptions</li> <li>Multi-Tier Buffering: Combines in-memory and persistent Redis buffering to guarantee zero data loss during outages or maintenance windows</li> </ul>"},{"location":"#operational-excellence","title":"Operational Excellence","text":"<ul> <li>Dynamic Policy Management: Supports real-time security policy updates without application restart, enabling immediate threat response</li> <li>Protocol-Based Extensibility: Provides clean abstractions for custom transport implementations, storage backends, and data processors</li> <li>Comprehensive Observability: Captures granular metrics including response times, error rates, and resource utilization for complete operational visibility</li> </ul>"},{"location":"#data-governance","title":"Data Governance","text":"<ul> <li>Privacy-First Design: Implements configurable data redaction for sensitive headers and payload truncation to meet compliance requirements</li> <li>Intelligent Rate Limiting: Prevents API exhaustion through client-side rate limiting with adaptive backpressure</li> <li>Health Monitoring: Continuous self-diagnostics with automatic health reporting and degradation detection</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>The FastAPI Guard Agent supports standard Python package management workflows:</p> <pre><code>pip install fastapi-guard-agent\n</code></pre>"},{"location":"#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.10 or higher (3.11+ recommended for optimal performance)</li> <li>Compatible with all FastAPI versions</li> <li>Optional Redis 6.0+ for persistent buffering</li> </ul>"},{"location":"#implementation-patterns","title":"Implementation Patterns","text":""},{"location":"#primary-integration-pattern","title":"Primary Integration Pattern","text":"<p>The recommended approach leverages FastAPI Guard's built-in agent support for automatic telemetry collection:</p> <pre><code>from fastapi import FastAPI\nfrom guard import SecurityConfig, SecurityMiddleware\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    # Enable agent\n    enable_agent=True,\n    agent_api_key=\"your-api-key\",\n    agent_project_id=\"your-project-id\",\n\n    # Other security settings\n    enable_rate_limiting=True,\n    rate_limit=100,\n    rate_limit_window=60,\n)\n\nmiddleware = SecurityMiddleware(app, config=config)\n\n# Agent automatically initialized with comprehensive event collection\n</code></pre>"},{"location":"#advanced-usage-pattern","title":"Advanced Usage Pattern","text":"<p>For specialized use cases requiring direct agent control, such as custom event handling or integration with non-FastAPI Guard systems:</p> <pre><code>from fastapi import FastAPI\nfrom guard_agent import guard_agent, AgentConfig, SecurityEvent\nfrom guard_agent.utils import get_current_timestamp\n\napp = FastAPI()\n\n# Configure agent directly\nconfig = AgentConfig(\n    api_key=\"your-api-key\",\n    project_id=\"your-project-id\",\n    buffer_size=100,\n    flush_interval=30,\n)\n\nagent = guard_agent(config)\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    await agent.start()\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    await agent.stop()\n\n@app.post(\"/report-event\")\nasync def report_event():\n    # Manually send an event\n    event = SecurityEvent(\n        timestamp=get_current_timestamp(),\n        event_type=\"custom_rule_triggered\",\n        ip_address=\"192.168.1.100\",\n        action_taken=\"logged\",\n        reason=\"Manual event\",\n        endpoint=\"/report-event\",\n        method=\"POST\",\n    )\n    await agent.send_event(event)\n    return {\"status\": \"event sent\"}\n</code></pre>"},{"location":"#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"#redis-integration","title":"Redis Integration","text":"<p>For production deployments, enable Redis for persistent buffering:</p> <pre><code>from redis.asyncio import Redis\nfrom guard_agent.redis_handler import RedisHandler\n\n# Configure Redis\nredis_client = Redis.from_url(\"redis://localhost:6379\")\nredis_handler = RedisHandler(redis_client)\n\n# Initialize agent with Redis\nagent = guard_agent(config)\nawait agent.initialize_redis(redis_handler)\n</code></pre>"},{"location":"#custom-transport","title":"Custom Transport","text":"<p>Implement custom transport for specialized backends:</p> <pre><code>from guard_agent.protocols import TransportProtocol\nfrom guard_agent.models import SecurityEvent, SecurityMetric, AgentStatus, DynamicRules\n\nclass CustomTransport(TransportProtocol):\n    async def send_events(self, events: list[SecurityEvent]) -&gt; bool:\n        # Your custom implementation\n        return True\n\n    async def send_metrics(self, metrics: list[SecurityMetric]) -&gt; bool:\n        # Your custom implementation\n        return True\n\n    async def fetch_dynamic_rules(self) -&gt; DynamicRules | None:\n        # Your custom implementation\n        return None\n\n    async def send_status(self, status: AgentStatus) -&gt; bool:\n        # Your custom implementation\n        return True\n\n# Use custom transport\nagent = guard_agent(config)\nagent.transport = CustomTransport()\n</code></pre>"},{"location":"#data-models","title":"Data Models","text":""},{"location":"#securityevent","title":"SecurityEvent","text":"<p>Represents security-related events in your application:</p> <pre><code>from guard_agent.models import SecurityEvent\nfrom guard_agent.utils import get_current_timestamp\n\nevent = SecurityEvent(\n    timestamp=get_current_timestamp(),\n    event_type=\"ip_banned\",\n    ip_address=\"192.168.1.100\",\n    country=\"US\",\n    user_agent=\"Mozilla/5.0...\",\n    action_taken=\"block\",\n    reason=\"Rate limit exceeded\",\n    endpoint=\"/api/v1/login\",\n    method=\"POST\",\n    status_code=429,\n    response_time=0.125,\n    metadata={\"attempts\": 5, \"window\": 60}\n)\n\nawait agent.send_event(event)\n</code></pre>"},{"location":"#securitymetric","title":"SecurityMetric","text":"<p>Represents performance and usage metrics:</p> <pre><code>from guard_agent.models import SecurityMetric\n\nmetric = SecurityMetric(\n    timestamp=get_current_timestamp(),\n    metric_type=\"request_count\",\n    value=100.0,\n    endpoint=\"/api/v1/users\",\n    tags={\"method\": \"GET\", \"status\": \"200\"}\n)\n\nawait agent.send_metric(metric)\n</code></pre>"},{"location":"#dynamic-rules","title":"Dynamic Rules","text":"<p>Fetch and apply dynamic security rules from your SaaS backend:</p> <pre><code># Fetch current rules\nrules = await agent.get_dynamic_rules()\n\nif rules:\n    # Apply IP blacklist\n    if client_ip in rules.ip_blacklist:\n        # Block request\n        pass\n\n    # Apply rate limits\n    endpoint_limit = rules.endpoint_rate_limits.get(\"/api/sensitive\")\n    if endpoint_limit:\n        requests, window = endpoint_limit\n        # Apply endpoint-specific rate limit\n        pass\n\n    # Check emergency mode\n    if rules.emergency_mode:\n        # Apply stricter security measures\n        pass\n</code></pre>"},{"location":"#monitoring-and-health","title":"Monitoring and Health","text":""},{"location":"#agent-status","title":"Agent Status","text":"<p>Monitor agent health and performance:</p> <pre><code>status = await agent.get_status()\n\nprint(f\"Status: {status.status}\")  # healthy, degraded, error\nprint(f\"Uptime: {status.uptime}s\")\nprint(f\"Events sent: {status.events_sent}\")\nprint(f\"Buffer size: {status.buffer_size}\")\nprint(f\"Errors: {status.errors}\")\n</code></pre>"},{"location":"#statistics","title":"Statistics","text":"<p>Get detailed agent statistics:</p> <pre><code>stats = agent.get_stats()\n\nprint(f\"Running: {stats['running']}\")\nprint(f\"Events sent: {stats['events_sent']}\")\nprint(f\"Transport stats: {stats['transport_stats']}\")\nprint(f\"Buffer stats: {stats['buffer_stats']}\")\n</code></pre>"},{"location":"#error-handling","title":"Error Handling","text":""},{"location":"#circuit-breaker","title":"Circuit Breaker","text":"<p>The agent includes a circuit breaker to handle backend failures gracefully:</p> <pre><code># Check circuit breaker state\ntransport_stats = agent.transport.get_stats()\nif transport_stats[\"circuit_breaker_state\"] == \"OPEN\":\n    print(\"Backend is unavailable, circuit breaker is open\")\n</code></pre>"},{"location":"#retry-logic","title":"Retry Logic","text":"<p>Failed requests are automatically retried with exponential backoff:</p> <pre><code>config = AgentConfig(\n    api_key=\"your-api-key\",\n    retry_attempts=3,      # Number of retries\n    backoff_factor=1.5,    # Exponential backoff factor\n    timeout=30,            # Request timeout\n)\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Introduction</li> <li>Configuration</li> <li>Architecture</li> <li>Data Models</li> <li>Dynamic Rules</li> <li>Installation</li> <li>First Steps</li> <li>API Reference</li> </ul> <p>\ud83d\udcd6 Learn More in the Documentation</p>"},{"location":"installation/","title":"Installation Guide","text":"<p>This comprehensive guide provides detailed instructions for deploying FastAPI Guard Agent across various environments and configurations.</p>"},{"location":"installation/#system-requirements","title":"System Requirements","text":""},{"location":"installation/#python-runtime","title":"Python Runtime","text":"<p>FastAPI Guard Agent requires Python 3.10 or higher. For optimal performance and feature compatibility, Python 3.11+ is recommended.</p> <p>Verify your Python installation:</p> <pre><code>python --version\n</code></pre>"},{"location":"installation/#core-dependencies","title":"Core Dependencies","text":"<p>The following dependencies are automatically managed during installation:</p>"},{"location":"installation/#required-components","title":"Required Components","text":"<ul> <li><code>fastapi-guard</code> - Security middleware providing the integration framework</li> <li><code>pydantic</code> \u2265 2.0 - Type-safe data validation and serialization</li> <li><code>httpx</code> - High-performance async HTTP client with connection pooling</li> <li><code>typing-extensions</code> \u2265 4.0 - Enhanced type hints for Python 3.10 compatibility</li> </ul>"},{"location":"installation/#optional-components","title":"Optional Components","text":"<ul> <li><code>redis</code> \u2265 6.0.0 - Client library for persistent buffering (production recommended)</li> <li>Redis Server 6.0+ - External service for high-availability deployments</li> <li>ASGI Server - Uvicorn, Hypercorn, or similar for application hosting</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#standard-installation","title":"Standard Installation","text":"<p>For integrated deployments with FastAPI Guard:</p> <pre><code>pip install fastapi-guard fastapi-guard-agent\n</code></pre> <p>For standalone agent deployments:</p> <pre><code>pip install fastapi-guard-agent\n</code></pre>"},{"location":"installation/#version-specific-installation","title":"Version-Specific Installation","text":"<p>Pin to a specific version for reproducible deployments:</p> <pre><code>pip install fastapi-guard-agent==1.0.1\n</code></pre>"},{"location":"installation/#modern-python-packaging","title":"Modern Python Packaging","text":""},{"location":"installation/#poetry-integration","title":"Poetry Integration","text":"<pre><code>poetry add fastapi-guard-agent\n</code></pre> <p>For development dependencies:</p> <pre><code>poetry add --group dev fastapi-guard-agent\n</code></pre>"},{"location":"installation/#pip-tools-workflow","title":"pip-tools Workflow","text":"<p>Define in <code>requirements.in</code>:</p> <pre><code>fastapi-guard-agen==1.0.1\n</code></pre> <p>Generate locked requirements:</p> <pre><code>pip-compile requirements.in\npip-sync requirements.txt\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For contributors and advanced users requiring source access:</p> <pre><code>git clone https://github.com/rennf93/fastapi-guard-agent.git\ncd fastapi-guard-agent\npip install -e \".[dev]\"\n</code></pre> <p>Install pre-commit hooks for code quality:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"installation/#container-deployment","title":"Container Deployment","text":""},{"location":"installation/#production-dockerfile","title":"Production Dockerfile","text":"<p>Optimized multi-stage build for minimal image size:</p> <pre><code>FROM python:3.11-slim as builder\n\n# Build dependencies\nWORKDIR /build\nCOPY requirements.txt .\nRUN pip install --user -r requirements.txt fastapi-guard-agent\n\nFROM python:3.11-slim\n\n# Copy installed packages\nCOPY --from=builder /root/.local /root/.local\nENV PATH=/root/.local/bin:$PATH\n\n# Application setup\nWORKDIR /app\nCOPY . .\n\n# Security: Run as non-root user\nRUN useradd -m -u 1000 appuser &amp;&amp; chown -R appuser:appuser /app\nUSER appuser\n\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"installation/#installation-verification","title":"Installation Verification","text":"<p>Comprehensive validation ensures proper deployment:</p>"},{"location":"installation/#1-package-import-validation","title":"1. Package Import Validation","text":"<p>Verify successful installation through systematic import testing:</p> <pre><code># test_installation.py\ntry:\n    # Validate FastAPI Guard installation\n    from guard import SecurityConfig, SecurityMiddleware\n    print(\"\u2705 FastAPI Guard installation verified\")\n\n    # Validate Agent module availability\n    from guard_agent import __version__\n    from guard_agent.client import guard_agent\n    from guard_agent.models import AgentConfig\n    print(f\"\u2705 FastAPI Guard Agent {__version__} successfully installed\")\nexcept ImportError as e:\n    print(f\"\u274c Installation validation failed: {e}\")\n</code></pre> <p>Run the test:</p> <pre><code>python test_installation.py\n</code></pre>"},{"location":"installation/#2-configuration-validation-test","title":"2. Configuration Validation Test","text":"<p>Validate proper integration between FastAPI Guard and the telemetry agent:</p> <pre><code># test_config.py\nfrom fastapi import FastAPI\nfrom guard import SecurityConfig, SecurityMiddleware\n\ntry:\n    app = FastAPI()\n\n    # Validate integrated configuration\n    config = SecurityConfig(\n        enable_agent=True,\n        agent_api_key=\"test-key\",\n        agent_project_id=\"test-project\"\n    )\n    middleware = SecurityMiddleware(app, config=config)\n    print(\"\u2705 Security middleware with telemetry pipeline successfully configured\")\nexcept Exception as e:\n    print(f\"\u274c Configuration validation failed: {e}\")\n</code></pre>"},{"location":"installation/#3-redis-connectivity-validation-production-environments","title":"3. Redis Connectivity Validation (Production Environments)","text":"<p>For production deployments utilizing Redis for persistent buffering:</p> <pre><code># test_redis.py\nimport asyncio\nfrom redis.asyncio import Redis\n\nasync def validate_redis_connectivity():\n    try:\n        redis = Redis.from_url(\"redis://localhost:6379\")\n        await redis.ping()\n        print(\"\u2705 Redis connectivity validated - persistent buffering available\")\n    except Exception as e:\n        print(f\"\u274c Redis connectivity validation failed: {e}\")\n    finally:\n        await redis.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(validate_redis_connectivity())\n</code></pre>"},{"location":"installation/#configuration-verification","title":"Configuration Verification","text":"<p>Create a minimal application to ensure everything works:</p> <pre><code># minimal_test.py\nfrom fastapi import FastAPI\nfrom guard import SecurityConfig, SecurityMiddleware\n\napp = FastAPI()\n\n# Configure FastAPI Guard with agent\nconfig = SecurityConfig(\n    # Basic security\n    enable_rate_limiting=True,\n    rate_limit=100,\n\n    # Enable agent\n    enable_agent=True,\n    agent_api_key=\"your-test-api-key\",\n    agent_project_id=\"your-test-project\",\n    agent_endpoint=\"https://api.fastapi-guard.com\"\n)\n\n# Add middleware - agent starts automatically\nmiddleware = SecurityMiddleware(app, config=config)\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"FastAPI Guard Agent is running!\"}\n\n@app.get(\"/test\")\nasync def test():\n    return {\"agent_enabled\": config.enable_agent}\n\n# Run with: uvicorn minimal_test:app --reload\n</code></pre>"},{"location":"installation/#troubleshooting-guide","title":"Troubleshooting Guide","text":""},{"location":"installation/#module-import-failures","title":"Module Import Failures","text":"<p>Symptom: <code>ModuleNotFoundError: No module named 'guard_agent'</code></p> <p>Resolution Strategies: 1. Ensure you're using the correct Python environment:    <pre><code>which python\npip list | grep fastapi-guard-agent\n</code></pre></p> <ol> <li> <p>If using virtual environments, make sure it's activated:    <pre><code>source venv/bin/activate  # Linux/Mac\n# or\nvenv\\Scripts\\activate     # Windows\n</code></pre></p> </li> <li> <p>Reinstall the package:    <pre><code>pip uninstall fastapi-guard-agent\npip install fastapi-guard-agent\n</code></pre></p> </li> </ol>"},{"location":"installation/#redis-connectivity-issues","title":"Redis Connectivity Issues","text":"<p>Symptom: <code>ConnectionError: Error connecting to Redis</code></p> <p>Resolution Strategies: 1. Ensure Redis server is running:    <pre><code>redis-cli ping\n</code></pre></p> <ol> <li> <p>Check Redis configuration in your agent config:    <pre><code># Make sure Redis URL is correct\nredis = Redis.from_url(\"redis://localhost:6379/0\")\n</code></pre></p> </li> <li> <p>Install Redis server if not installed:    <pre><code># Ubuntu/Debian\nsudo apt-get install redis-server\n\n# macOS with Homebrew\nbrew install redis\n\n# Start Redis\nredis-server\n</code></pre></p> </li> </ol>"},{"location":"installation/#network-transport-failures","title":"Network Transport Failures","text":"<p>Symptom: <code>httpx.HTTPError</code> or connection timeout exceptions</p> <p>Resolution Strategies: 1. Check your API endpoint configuration:    <pre><code>config = AgentConfig(\n    endpoint=\"https://api.fastapi-guard.com\",  # Ensure this is correct\n    api_key=\"your-api-key\"\n)\n</code></pre></p> <ol> <li> <p>Verify network connectivity:    <pre><code>curl -I https://api.fastapi-guard.com/health\n</code></pre></p> </li> <li> <p>Check firewall settings and proxy configuration if behind corporate network.</p> </li> </ol>"},{"location":"installation/#installation-permission-errors","title":"Installation Permission Errors","text":"<p>Symptom: <code>PermissionError</code> during package installation</p> <p>Resolution Strategies: 1. Use <code>--user</code> flag for user-level installation:    <pre><code>pip install --user fastapi-guard-agent\n</code></pre></p> <ol> <li> <p>Use virtual environment (recommended):    <pre><code>python -m venv venv\nsource venv/bin/activate\npip install fastapi-guard-agent\n</code></pre></p> </li> <li> <p>On systems with permission issues, consider using <code>sudo</code> (not recommended):    <pre><code>sudo pip install fastapi-guard-agent\n</code></pre></p> </li> </ol>"},{"location":"installation/#post-installation-guidance","title":"Post-Installation Guidance","text":"<p>Following successful installation of <code>fastapi-guard-agent</code>, proceed with:</p> <ol> <li>Getting Started Guide - Comprehensive implementation walkthrough</li> <li>Configuration Reference - Detailed configuration parameter documentation</li> <li>Integration Patterns - Advanced integration architectures</li> <li>Implementation Examples - Production-ready deployment patterns</li> </ol>"},{"location":"installation/#system-requirements-summary","title":"System Requirements Summary","text":"Component Requirement Python 3.10+ (3.11+ recommended) Memory 64MB+ available RAM Network HTTPS outbound access Storage 10MB+ disk space Redis Optional but recommended for production"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#v102-2025-09-12","title":"v1.0.2 (2025-09-12)","text":""},{"location":"release-notes/#enhancements-v102","title":"Enhancements (v1.0.2)","text":"<ul> <li>Added dynamic rule updated event type.</li> </ul>"},{"location":"release-notes/#v101-2025-08-07","title":"v1.0.1 (2025-08-07)","text":""},{"location":"release-notes/#enhancements-v101","title":"Enhancements (v1.0.1)","text":"<ul> <li>Added path_excluded event type.</li> </ul>"},{"location":"release-notes/#v100-2025-07-24","title":"v1.0.0 (2025-07-24)","text":"<p>Official Release</p>"},{"location":"release-notes/#v011-2025-07-09","title":"v0.1.1 (2025-07-09)","text":""},{"location":"release-notes/#enhancements-v011","title":"Enhancements (v0.1.1)","text":"<ul> <li>Standardized Redis Protocl/Manager methods across libraries.</li> </ul>"},{"location":"release-notes/#v010-2025-07-08","title":"v0.1.0 (2025-07-08)","text":""},{"location":"release-notes/#enhancements-v010","title":"Enhancements (v0.1.0)","text":"<ul> <li>Switched from aiohttp to httpx for HTTP client.</li> <li>Completed implementation.</li> <li>100% test coverage.</li> </ul>"},{"location":"release-notes/#v001-2025-06-22","title":"v0.0.1 (2025-06-22)","text":""},{"location":"release-notes/#new-features-v001","title":"New Features (v0.0.1)","text":"<ul> <li>Initial release FastAPI Guard Agent.</li> </ul>"},{"location":"api/overview/","title":"API Overview","text":"<p>The FastAPI Guard Agent API provides a comprehensive, protocol-driven architecture for enterprise-grade security telemetry. Designed with extensibility and reliability at its core, the API enables seamless integration with diverse monitoring ecosystems while maintaining strict performance guarantees.</p>"},{"location":"api/overview/#system-architecture","title":"System Architecture","text":"<p>The agent implements a layered architecture optimized for high-throughput telemetry collection with minimal application impact:</p> <pre><code>graph TB\n    subgraph \"FastAPI Application\"\n        FG[FastAPI Guard&lt;br/&gt;Security Middleware]\n        SC[SecurityConfig&lt;br/&gt;enable_agent=True]\n    end\n\n    subgraph \"FastAPI Guard Agent (Auto-initialized)\"\n        AH[Agent Handler&lt;br/&gt;Central Orchestrator]\n        EB[Event Buffer&lt;br/&gt;High-Performance Queue]\n        TR[HTTP Transport&lt;br/&gt;Resilient Network Layer]\n\n        subgraph \"Protocol Abstractions\"\n            BP[Buffer Protocol]\n            TP[Transport Protocol]\n            RP[Redis Protocol]\n            AP[Agent Protocol]\n        end\n    end\n\n    subgraph \"External Systems\"\n        RD[(Redis&lt;br/&gt;Persistent Buffer)]\n        BE[Management Platform&lt;br/&gt;Analytics &amp; Policy Engine]\n    end\n\n    SC --&gt; FG\n    FG --&gt; AH\n    AH --&gt; EB\n    EB --&gt; TR\n    EB -.-&gt; RD\n    TR --&gt; BE\n\n    AH -.-&gt; BP\n    AH -.-&gt; TP\n    EB -.-&gt; RP\n    AH -.-&gt; AP\n</code></pre>"},{"location":"api/overview/#core-components","title":"Core Components","text":""},{"location":"api/overview/#1-agent-handler-guardagenthandler","title":"1. Agent Handler (<code>GuardAgentHandler</code>)","text":"<p>The central orchestration component responsible for coordinating all telemetry operations.</p> <p>Core Responsibilities: - Lifecycle Management: Orchestrates initialization, operation, and graceful shutdown sequences - Event Processing: Implements high-throughput event ingestion with backpressure handling - Metric Aggregation: Performs efficient metric collection with configurable sampling rates - Task Coordination: Manages asynchronous operations including buffer flushing and policy synchronization</p> <p>Basic Usage (Auto-integrated with FastAPI Guard): <pre><code>from fastapi import FastAPI\nfrom guard import SecurityConfig, SecurityMiddleware\n\n# Configure with agent enabled\nconfig = SecurityConfig(\n    enable_agent=True,\n    agent_api_key=\"your-api-key\",\n    agent_project_id=\"your-project-id\",\n    agent_endpoint=\"https://api.fastapi-guard.com\",\n)\n\napp = FastAPI()\nmiddleware = SecurityMiddleware(app, config=config)\n# Agent starts automatically with middleware\n</code></pre></p> <p>Direct Usage (Advanced): <pre><code>from guard_agent import guard_agent, AgentConfig\n\n# Initialize directly\nconfig = AgentConfig(\n    api_key=\"your-api-key\",\n    project_id=\"your-project-id\",\n)\nagent = guard_agent(config)\n\n# Lifecycle\nawait agent.start()\nawait agent.stop()\n\n# Send data manually\nawait agent.send_event(security_event)\nawait agent.send_metric(performance_metric)\n</code></pre></p>"},{"location":"api/overview/#2-event-buffer-eventbuffer","title":"2. Event Buffer (<code>EventBuffer</code>)","text":"<p>High-performance buffering subsystem engineered for optimal throughput and reliability.</p> <p>Technical Capabilities: - Lock-Free Architecture: Utilizes deque-based storage for minimal contention - Persistent Buffering: Optional Redis integration for durability across restarts - Intelligent Flushing: Adaptive algorithms balance latency and efficiency - Concurrency Safety: Full async/await compatibility with thread-safe operations</p> <p>Usage Patterns: <pre><code>from guard_agent.buffer import EventBuffer\nfrom guard_agent.models import SecurityEvent\n\n# Create buffer\nbuffer = EventBuffer(\n    max_size=1000,\n    flush_interval=60,\n    redis_handler=redis_client  # optional\n)\n\n# Add events\nawait buffer.add_event(security_event)\nawait buffer.add_metric(performance_metric)\n\n# Manual flush\nevents, metrics = await buffer.flush()\n</code></pre></p>"},{"location":"api/overview/#3-http-transport-httptransport","title":"3. HTTP Transport (<code>HTTPTransport</code>)","text":"<p>Enterprise-grade network layer implementing industry best practices for reliable data delivery.</p> <p>Reliability Features: - Intelligent Retry: Exponential backoff with jitter prevents thundering herd - Circuit Breaker: Automatic failure detection with graceful degradation - Adaptive Rate Limiting: Dynamic throttling based on backend capacity - Comprehensive Telemetry: Real-time transport statistics for operational visibility</p> <p>Configuration: <pre><code>from guard_agent.transport import HTTPTransport\n\ntransport = HTTPTransport(\n    backend_url=\"https://your-backend.com\",\n    api_key=\"your-api-key\",\n    timeout=30,\n    max_retries=3,\n    backoff_factor=2.0,\n    rate_limit_requests=100,\n    rate_limit_period=60\n)\n</code></pre></p>"},{"location":"api/overview/#4-data-models","title":"4. Data Models","text":"<p>Strongly-typed data structures leveraging Pydantic for validation and serialization.</p> <p>Primary Models: - <code>AgentConfig</code>: Comprehensive configuration with validation and defaults - <code>SecurityEvent</code>: Rich security event representation with contextual metadata - <code>SecurityMetric</code>: Performance metrics with dimensional tagging support - <code>EventBatch</code>: Optimized batch container for network efficiency - <code>AgentStatus</code>: Real-time operational telemetry and health indicators</p>"},{"location":"api/overview/#5-protocol-system","title":"5. Protocol System","text":"<p>Clean abstraction layer enabling custom implementations while maintaining compatibility.</p> <p>Protocol Interfaces: - <code>AgentHandlerProtocol</code>: Defines agent lifecycle and event handling contracts - <code>BufferProtocol</code>: Specifies buffering semantics and performance guarantees - <code>TransportProtocol</code>: Establishes network transport requirements and capabilities - <code>RedisHandlerProtocol</code>: Standardizes persistent storage integration patterns</p>"},{"location":"api/overview/#api-reference-by-module","title":"API Reference by Module","text":""},{"location":"api/overview/#core-handler-api","title":"Core Handler API","text":""},{"location":"api/overview/#guardagenthandler","title":"<code>GuardAgentHandler</code>","text":"<p>The main entry point for all agent operations.</p> <pre><code>class GuardAgentHandler:\n    def __init__(self, config: AgentConfig) -&gt; None: ...\n\n    # Lifecycle Management\n    async def start(self) -&gt; None: ...\n    async def stop(self) -&gt; None: ...\n    async def is_running(self) -&gt; bool: ...\n\n    # Event &amp; Metric Handling\n    async def send_event(self, event: SecurityEvent) -&gt; None: ...\n    async def send_metric(self, metric: SecurityMetric) -&gt; None: ...\n\n    # Status &amp; Health\n    async def get_status(self) -&gt; AgentStatus: ...\n    async def health_check(self) -&gt; bool: ...\n\n    # Configuration\n    async def update_config(self, config: AgentConfig) -&gt; None: ...\n    async def get_dynamic_rules(self) -&gt; DynamicRules: ...\n</code></pre> <p>Key Methods:</p> Method Description Usage <code>start()</code> Initialize agent and start background tasks Called on app startup <code>stop()</code> Graceful shutdown with data preservation Called on app shutdown <code>send_event()</code> Send security event to buffer Auto-called by FastAPI Guard <code>send_metric()</code> Send performance metric Manual or auto collection <code>get_status()</code> Get real-time agent status Health monitoring"},{"location":"api/overview/#buffer-api","title":"Buffer API","text":""},{"location":"api/overview/#eventbuffer","title":"<code>EventBuffer</code>","text":"<p>Intelligent event and metric buffering with persistence.</p> <pre><code>class EventBuffer:\n    def __init__(\n        self,\n        max_size: int = 1000,\n        flush_interval: int = 60,\n        redis_handler: Optional[RedisHandlerProtocol] = None\n    ) -&gt; None: ...\n\n    # Data Management\n    async def add_event(self, event: SecurityEvent) -&gt; None: ...\n    async def add_metric(self, metric: SecurityMetric) -&gt; None: ...\n    async def flush(self) -&gt; Tuple[List[SecurityEvent], List[SecurityMetric]]: ...\n\n    # Status &amp; Configuration\n    def get_stats(self) -&gt; Dict[str, Any]: ...\n    async def clear(self) -&gt; None: ...\n    def is_full(self) -&gt; bool: ...\n</code></pre>"},{"location":"api/overview/#transport-api","title":"Transport API","text":""},{"location":"api/overview/#httptransport","title":"<code>HTTPTransport</code>","text":"<p>Enterprise-grade HTTP client with resilience features.</p> <pre><code>class HTTPTransport:\n    def __init__(\n        self,\n        backend_url: str,\n        api_key: str,\n        timeout: int = 30,\n        max_retries: int = 3,\n        backoff_factor: float = 2.0\n    ) -&gt; None: ...\n\n    # Data Transmission\n    async def send_batch(self, batch: EventBatch) -&gt; bool: ...\n    async def send_heartbeat(self, status: AgentStatus) -&gt; bool: ...\n\n    # Health &amp; Status\n    async def test_connection(self) -&gt; bool: ...\n    def get_stats(self) -&gt; TransportStats: ...\n\n    # Configuration\n    async def update_rules(self) -&gt; Optional[DynamicRules]: ...\n</code></pre>"},{"location":"api/overview/#models-api","title":"Models API","text":""},{"location":"api/overview/#core-data-models","title":"Core Data Models","text":"<p>AgentConfig <pre><code>class AgentConfig(BaseModel):\n    backend_url: str\n    api_key: str\n    buffer_size: int = 1000\n    flush_interval: int = 60\n    enabled: bool = True\n    # ... additional fields\n</code></pre></p> <p>SecurityEvent <pre><code>class SecurityEvent(BaseModel):\n    event_type: EventType\n    source_ip: str\n    timestamp: datetime\n    description: str\n    metadata: Optional[Dict[str, Any]] = None\n    # ... additional fields\n</code></pre></p> <p>SecurityMetric <pre><code>class SecurityMetric(BaseModel):\n    metric_type: MetricType\n    value: Union[int, float]\n    timestamp: datetime\n    metadata: Optional[Dict[str, Any]] = None\n    # ... additional fields\n</code></pre></p>"},{"location":"api/overview/#implementation-patterns","title":"Implementation Patterns","text":""},{"location":"api/overview/#pattern-1-standard-deployment","title":"Pattern 1: Standard Deployment","text":"<pre><code>from fastapi import FastAPI\nfrom guard import SecurityConfig, SecurityMiddleware\n\napp = FastAPI()\n\n# Configure FastAPI Guard with agent\nconfig = SecurityConfig(\n    # Enable agent\n    enable_agent=True,\n    agent_api_key=\"your-api-key\",\n    agent_project_id=\"your-project-id\",\n\n    # Security settings\n    enable_rate_limiting=True,\n    enable_ip_banning=True,\n    enable_penetration_detection=True,\n)\n\n# Add middleware - agent starts automatically\nmiddleware = SecurityMiddleware(app, config=config)\n</code></pre>"},{"location":"api/overview/#pattern-2-custom-event-integration","title":"Pattern 2: Custom Event Integration","text":"<pre><code>from guard_agent import guard_agent, AgentConfig, SecurityEvent\nfrom guard_agent.utils import get_current_timestamp\n\n# Get agent instance\nconfig = AgentConfig(\n    api_key=\"your-api-key\",\n    project_id=\"your-project-id\",\n)\nagent = guard_agent(config)\n\nasync def custom_security_check(request):\n    \"\"\"Custom security validation with event reporting.\"\"\"\n\n    if is_suspicious(request):\n        # Create custom event\n        event = SecurityEvent(\n            timestamp=get_current_timestamp(),\n            event_type=\"custom_rule_triggered\",\n            ip_address=request.client.host,\n            action_taken=\"blocked\",\n            reason=\"Custom security check failed\",\n            endpoint=str(request.url.path),\n            method=request.method,\n            metadata={\n                \"check_type\": \"business_logic\",\n                \"severity\": \"high\"\n            }\n        )\n\n        # Send to agent\n        await agent.send_event(event)\n\n        return False\n\n    return True\n</code></pre>"},{"location":"api/overview/#pattern-3-performance-monitoring","title":"Pattern 3: Performance Monitoring","text":"<pre><code>from guard_agent import guard_agent, SecurityMetric\nfrom guard_agent.utils import get_current_timestamp\nimport time\n\n# Get agent instance (singleton)\nagent = guard_agent(AgentConfig(\n    api_key=\"your-api-key\",\n    project_id=\"your-project-id\",\n))\n\nasync def monitor_endpoint_performance():\n    \"\"\"Monitor endpoint performance and send metrics.\"\"\"\n\n    start_time = time.time()\n\n    try:\n        # Your endpoint logic\n        result = await process_request()\n\n        # Success metric\n        await agent.send_metric(SecurityMetric(\n            timestamp=get_current_timestamp(),\n            metric_type=\"response_time\",\n            value=time.time() - start_time,\n            endpoint=\"/api/process\",\n            tags={\"status\": \"success\"}\n        ))\n\n        return result\n\n    except Exception as e:\n        # Error metric\n        await agent.send_metric(SecurityMetric(\n            timestamp=get_current_timestamp(),\n            metric_type=\"error_rate\",\n            value=1.0,\n            endpoint=\"/api/process\",\n            tags={\"error\": str(type(e).__name__)}\n        ))\n        raise\n</code></pre>"},{"location":"api/overview/#pattern-4-health-monitoring","title":"Pattern 4: Health Monitoring","text":"<pre><code>@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Application health check including agent status.\"\"\"\n\n    agent_healthy = await agent.health_check()\n    agent_status = await agent.get_status()\n\n    return {\n        \"status\": \"healthy\" if agent_healthy else \"degraded\",\n        \"agent\": {\n            \"running\": agent_status.is_running,\n            \"events_processed\": agent_status.events_processed,\n            \"last_flush\": agent_status.last_flush_time,\n            \"buffer_size\": agent_status.buffer_size\n        }\n    }\n</code></pre>"},{"location":"api/overview/#reliability-patterns","title":"Reliability Patterns","text":""},{"location":"api/overview/#graceful-degradation","title":"Graceful Degradation","text":"<p>The agent implements comprehensive failure isolation to protect application availability:</p> <pre><code>try:\n    await agent.send_event(event)\nexcept Exception as e:\n    # Agent failure doesn't break your app\n    logger.warning(f\"Agent error: {e}\")\n    # Application continues normally\n</code></pre>"},{"location":"api/overview/#circuit-breaker-implementation","title":"Circuit Breaker Implementation","text":"<p>Advanced failure detection with automatic recovery mechanisms:</p> <pre><code># Circuit breaker state machine:\n# - CLOSED: Normal operation with request forwarding\n# - OPEN: Fast-fail mode preventing backend overload\n# - HALF_OPEN: Controlled recovery testing with limited traffic\n</code></pre>"},{"location":"api/overview/#retry-strategies","title":"Retry Strategies","text":"<p>Sophisticated retry algorithms optimize for both reliability and backend protection:</p> <pre><code># Adaptive retry configuration:\nmax_retries: 3                    # Configurable retry limit\nbackoff_factor: 2.0              # Exponential growth factor\njitter: True                     # Randomization prevents synchronized retries\nmax_delay: 60                    # Caps maximum retry delay\n</code></pre>"},{"location":"api/overview/#performance-engineering","title":"Performance Engineering","text":""},{"location":"api/overview/#memory-optimization","title":"Memory Optimization","text":"<p>Strategic memory management for various deployment scales:</p> <ul> <li>Buffer Sizing: Dynamic sizing based on traffic patterns and memory constraints</li> <li>Flush Strategies: Adaptive algorithms balance latency requirements with efficiency</li> <li>Persistent Buffering: Redis integration for memory-constrained environments</li> </ul>"},{"location":"api/overview/#network-optimization","title":"Network Optimization","text":"<p>Advanced techniques minimize bandwidth and latency:</p> <ul> <li>Intelligent Batching: Adaptive batch sizes based on network conditions</li> <li>Compression: Automatic gzip compression for payload optimization</li> <li>Connection Management: HTTP/2 multiplexing with connection pooling</li> </ul>"},{"location":"api/overview/#deployment-profiles","title":"Deployment Profiles","text":"<pre><code># Microservice deployment (low memory, high frequency)\nconfig = AgentConfig(buffer_size=100, flush_interval=10)\n\n# Standard API service (balanced profile)\nconfig = AgentConfig(buffer_size=1000, flush_interval=30)\n\n# High-throughput gateway (optimized for volume)\nconfig = AgentConfig(buffer_size=10000, flush_interval=60)\n</code></pre>"},{"location":"tutorial/getting-started/","title":"Getting Started","text":"<p>This comprehensive guide provides a systematic approach to deploying FastAPI Guard Agent within your application infrastructure. Upon completion, you will have established a production-ready security telemetry pipeline capable of real-time threat detection and response.</p>"},{"location":"tutorial/getting-started/#architecture-overview","title":"Architecture Overview","text":"<p>The FastAPI Guard Agent operates as an intelligent telemetry layer within your security infrastructure, providing:</p> <ol> <li>Automated Collection - Captures security events and performance metrics through deep integration with FastAPI Guard middleware</li> <li>Intelligent Buffering - Implements multi-tier data management with memory and persistent storage options for optimal performance</li> <li>Reliable Transmission - Ensures guaranteed delivery of telemetry data through enterprise-grade transport mechanisms</li> <li>Dynamic Configuration - Enables real-time security policy updates without service interruption</li> </ol>"},{"location":"tutorial/getting-started/#prerequisites","title":"Prerequisites","text":""},{"location":"tutorial/getting-started/#system-requirements","title":"System Requirements","text":"<ul> <li>Python Runtime: Version 3.8 or higher (3.11+ recommended for optimal performance)</li> <li>Package Installation: FastAPI Guard Agent via pip (Installation Guide)</li> <li>Application Framework: Existing or new FastAPI application</li> <li>Authentication: Valid API credentials from the FastAPI Guard management platform</li> <li>Optional Components: Redis 6.0+ for persistent buffering in production environments</li> </ul>"},{"location":"tutorial/getting-started/#implementation-guide","title":"Implementation Guide","text":""},{"location":"tutorial/getting-started/#step-1-standard-integration-pattern","title":"Step 1: Standard Integration Pattern","text":"<p>The recommended deployment leverages FastAPI Guard's native agent support for automatic telemetry collection:</p> <pre><code># main.py\nfrom fastapi import FastAPI\nfrom guard import SecurityConfig, SecurityMiddleware\n\napp = FastAPI(title=\"My Secure API\")\n\n# Configure FastAPI Guard with agent enabled\nconfig = SecurityConfig(\n    # Basic security settings\n    auto_ban_threshold=5,\n    auto_ban_duration=300,\n    enable_rate_limiting=True,\n    rate_limit=100,\n    rate_limit_window=60,\n\n    # Enable agent for telemetry\n    enable_agent=True,\n    agent_api_key=\"your-api-key-here\",      # Replace with your actual API key\n    agent_project_id=\"your-project-id\",     # Replace with your project ID\n    agent_endpoint=\"https://api.fastapi-guard.com\",  # Default SaaS endpoint\n\n    # Agent configuration\n    agent_buffer_size=100,                  # Buffer up to 100 events\n    agent_flush_interval=30,                # Send data every 30 seconds\n    agent_enable_events=True,               # Enable security event collection\n    agent_enable_metrics=True,              # Enable performance metrics\n\n    # Enable dynamic rules from SaaS\n    enable_dynamic_rules=True,\n    dynamic_rule_interval=300,              # Check for rule updates every 5 minutes\n)\n\n# Add security middleware - agent starts automatically\nmiddleware = SecurityMiddleware(app, config=config)\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello, World!\"}\n\n@app.get(\"/health\")\nasync def health():\n    return {\"status\": \"healthy\", \"agent_enabled\": config.enable_agent}\n</code></pre> <p>With this configuration, the agent provides: - Comprehensive security event capture across all middleware operations - Real-time performance telemetry with sub-second granularity - Automatic synchronization of security policies from the management platform</p>"},{"location":"tutorial/getting-started/#step-2-configuration-architecture","title":"Step 2: Configuration Architecture","text":"<p>The agent configuration is seamlessly integrated within FastAPI Guard's SecurityConfig, providing a unified interface for all security settings:</p> <pre><code>from guard import SecurityConfig\n\nconfig = SecurityConfig(\n    # Agent-specific settings (prefix: agent_)\n    enable_agent=True,                    # Enable/disable agent\n    agent_api_key=\"your-api-key\",         # Your SaaS platform API key\n    agent_project_id=\"your-project-id\",   # Your project identifier\n    agent_endpoint=\"https://api.fastapi-guard.com\",  # SaaS platform endpoint\n    agent_buffer_size=100,                # Max events in memory buffer\n    agent_flush_interval=30,              # Seconds between data transmissions\n    agent_enable_events=True,             # Collect security events\n    agent_enable_metrics=True,            # Collect performance metrics\n    agent_retry_attempts=3,               # HTTP retry attempts\n    agent_timeout=30,                     # HTTP request timeout\n\n    # Dynamic rules settings\n    enable_dynamic_rules=True,            # Enable dynamic rule fetching\n    dynamic_rule_interval=300,            # Seconds between rule updates\n\n    # Standard FastAPI Guard settings\n    enable_rate_limiting=True,\n    enable_ip_banning=True,\n    enable_penetration_detection=True,\n    # ... other security settings\n)\n</code></pre>"},{"location":"tutorial/getting-started/#step-3-data-flow-architecture","title":"Step 3: Data Flow Architecture","text":"<p>The agent implements a sophisticated data pipeline designed for reliability and performance:</p> <pre><code>graph TD\n    A[FastAPI App] --&gt; B[Security Event]\n    A --&gt; C[Performance Metric]\n    B --&gt; D[Event Buffer]\n    C --&gt; D\n    D --&gt; E{Buffer Full?}\n    E --&gt;|Yes| F[HTTP Transport]\n    E --&gt;|No| G[Wait for Interval]\n    G --&gt; E\n    F --&gt; H[SaaS Backend]\n    H --&gt; I[Dynamic Rules]\n    I --&gt; A\n</code></pre> <p>Pipeline Components:</p> <ol> <li>Event Generation: Security violations and performance metrics are captured at the middleware layer</li> <li>Intelligent Buffering: Multi-tier buffering system optimizes for both latency and throughput</li> <li>Batch Transmission: Efficient batching algorithms minimize network overhead while maintaining low latency</li> <li>Backend Processing: Cloud-based analytics engine processes telemetry for threat detection and policy updates</li> <li>Policy Synchronization: Updated security rules are atomically applied without service disruption</li> </ol>"},{"location":"tutorial/getting-started/#step-4-advanced-security-controls","title":"Step 4: Advanced Security Controls","text":"<p>FastAPI Guard's decorator system provides granular security controls with automatic telemetry integration:</p> <pre><code>from fastapi import FastAPI\nfrom guard import SecurityConfig, SecurityMiddleware\nfrom guard.decorators import SecurityDecorator\n\napp = FastAPI(title=\"My Secure API with Enhanced Security\")\n\n# Configure with agent\nconfig = SecurityConfig(\n    enable_agent=True,\n    agent_api_key=\"your-api-key\",\n    agent_project_id=\"your-project-id\",\n    # ... other settings\n)\n\nmiddleware = SecurityMiddleware(app, config=config)\nguard = SecurityDecorator(config)\n\n# Connect decorator to middleware for behavioral tracking\nmiddleware.set_decorator_handler(guard)\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello, World!\"}\n\n@app.get(\"/public\")\n@guard.rate_limit(requests=5, window=60)\nasync def public_endpoint():\n    \"\"\"Rate limited endpoint - events sent automatically to agent.\"\"\"\n    return {\"message\": \"This endpoint has rate limiting\"}\n\n@app.get(\"/admin\")\n@guard.require_ip(whitelist=[\"127.0.0.1\", \"10.0.0.0/8\"])\n@guard.rate_limit(requests=2, window=300)\nasync def admin_endpoint():\n    \"\"\"Admin endpoint with IP restrictions - all violations logged to agent.\"\"\"\n    return {\"message\": \"Admin access granted\"}\n\n@app.get(\"/api/sensitive\")\n@guard.rate_limit(requests=3, window=600)\n@guard.block_countries([\"CN\", \"RU\"])\nasync def sensitive_api():\n    \"\"\"Sensitive API with multiple security layers.\"\"\"\n    return {\"message\": \"Sensitive data accessed\"}\n</code></pre>"},{"location":"tutorial/getting-started/#step-5-deployment-validation","title":"Step 5: Deployment Validation","text":"<p>Comprehensive testing ensures proper agent operation:</p> <ol> <li> <p>Application Startup:    <pre><code>uvicorn main:app --reload --log-level info\n</code></pre></p> </li> <li> <p>Functional Verification:    <pre><code># Baseline connectivity test\ncurl http://localhost:8000/\n\n# Security event generation\ncurl -X POST http://localhost:8000/api/sensitive -d \"test_injection\"\n\n# Performance metric generation\ncurl http://localhost:8000/api/heavy-operation\n\n# Agent health verification\ncurl http://localhost:8000/health\n</code></pre></p> </li> <li> <p>Log Analysis: Verify proper initialization:    <pre><code>INFO:     FastAPI Guard security middleware initialized\nINFO:     Agent telemetry pipeline established\nINFO:     Dynamic rule synchronization active\n</code></pre></p> </li> <li> <p>Automatic Event Categories: The agent captures:</p> </li> <li>Rate limiting violations with request metadata</li> <li>IP-based access control events</li> <li>Geographic restriction violations</li> <li>Pattern-based threat detection</li> <li>Authentication and authorization failures</li> <li>Custom security rule triggers</li> </ol>"},{"location":"tutorial/getting-started/#deployment-patterns","title":"Deployment Patterns","text":""},{"location":"tutorial/getting-started/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<p>Development Environment: <pre><code># config_dev.py\nfrom guard import SecurityConfig\n\ndev_config = SecurityConfig(\n    # Development agent settings\n    enable_agent=True,\n    agent_api_key=\"dev-api-key\",\n    agent_project_id=\"my-app-dev\",\n    agent_buffer_size=10,          # Small buffer for immediate feedback\n    agent_flush_interval=5,        # Frequent flushes for testing\n\n    # Security settings for dev\n    enable_rate_limiting=True,\n    rate_limit=1000,               # Higher limits for testing\n    enable_ip_banning=False,       # Disable banning in dev\n)\n</code></pre></p> <p>Production Environment: <pre><code># config_prod.py\nfrom guard import SecurityConfig\n\nprod_config = SecurityConfig(\n    # Production agent settings\n    enable_agent=True,\n    agent_api_key=\"prod-api-key\",\n    agent_project_id=\"my-app-prod\",\n    agent_buffer_size=500,         # Larger buffer for efficiency\n    agent_flush_interval=60,       # Less frequent flushes\n    agent_retry_attempts=5,        # More retries for reliability\n\n    # Security settings for production\n    enable_rate_limiting=True,\n    rate_limit=100,\n    enable_ip_banning=True,\n    auto_ban_threshold=5,\n    enable_penetration_detection=True,\n\n    # Enable dynamic rules in production\n    enable_dynamic_rules=True,\n    dynamic_rule_interval=300,\n)\n</code></pre></p>"},{"location":"tutorial/getting-started/#fault-tolerance","title":"Fault Tolerance","text":"<p>The agent implements comprehensive error handling to ensure application stability:</p> <pre><code>from fastapi import FastAPI\nfrom guard import SecurityConfig, SecurityMiddleware\n\napp = FastAPI()\n\n# Even if agent fails, your app continues running\nconfig = SecurityConfig(\n    enable_agent=True,\n    agent_api_key=\"your-api-key\",\n    agent_project_id=\"your-project-id\",\n    # ... other settings\n)\n\ntry:\n    middleware = SecurityMiddleware(app, config=config)\n    logger.info(\"Security middleware initialized with telemetry pipeline\")\nexcept Exception as e:\n    logger.warning(f\"Telemetry initialization failed: {e}\")\n    # Application continues with security enforcement but without telemetry\n</code></pre>"},{"location":"tutorial/getting-started/#custom-event-handling-advanced","title":"Custom Event Handling (Advanced)","text":"<p>For scenarios requiring custom business logic events beyond standard security violations:</p> <pre><code>from guard_agent import guard_agent, AgentConfig, SecurityEvent\nfrom guard_agent.utils import get_current_timestamp\n\n# Get agent instance (singleton)\nconfig = AgentConfig(\n    api_key=\"your-api-key\",\n    project_id=\"your-project-id\",\n)\nagent = guard_agent(config)\n\n# Manually start/stop if not using FastAPI Guard\n@app.on_event(\"startup\")\nasync def startup():\n    await agent.start()\n\n@app.on_event(\"shutdown\")\nasync def shutdown():\n    await agent.stop()\n\n# Send custom events\n@app.post(\"/custom-action\")\nasync def custom_action(request: Request):\n    # Your business logic here\n\n    # Send custom event\n    event = SecurityEvent(\n        timestamp=get_current_timestamp(),\n        event_type=\"custom_rule_triggered\",\n        ip_address=request.client.host,\n        action_taken=\"logged\",\n        reason=\"Custom business rule\",\n        endpoint=\"/custom-action\",\n        method=\"POST\",\n        metadata={\n            \"custom_field\": \"custom_value\",\n            \"user_agent\": request.headers.get(\"user-agent\", \"\"),\n        }\n    )\n    await agent.send_event(event)\n\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"tutorial/getting-started/#integration-testing","title":"Integration Testing","text":"<p>Create a simple test to verify your integration:</p> <pre><code># test_integration.py\nimport pytest\nfrom httpx import AsyncClient\nfrom main import app\n\n@pytest.mark.asyncio\nasync def test_fastapi_guard_with_agent():\n    \"\"\"Test that FastAPI Guard with agent works correctly.\"\"\"\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Test normal endpoint\n        response = await client.get(\"/\")\n        assert response.status_code == 200\n\n        # Test rate limited endpoint\n        for i in range(6):\n            response = await client.get(\"/public\")\n            if i &lt; 5:\n                assert response.status_code == 200\n            else:\n                # Should be rate limited\n                assert response.status_code == 429\n\n        # Test IP restricted endpoint\n        response = await client.get(\"/admin\")\n        # Should work from localhost\n        assert response.status_code in [200, 403]\n\n        # All security events are automatically sent to the agent\n</code></pre>"}]}