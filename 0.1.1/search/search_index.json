{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAPI Guard Agent","text":"<p> fastapi-guard-agent is a companion reporting agent for FastAPI Guard. It seamlessly collects security events, performance metrics, and telemetry data from FastAPI Guard and transmits them to your SaaS backend for centralized monitoring, analysis, and dynamic rule management. </p> <p> </p> <p> </p> <p> </p> <p><code>fastapi-guard-agent</code> is a companion agent for the <code>fastapi-guard</code> security library. It's designed to seamlessly integrate with your FastAPI application and <code>fastapi-guard</code> to provide powerful, real-time security monitoring and threat intelligence by collecting security events, performance metrics, and other telemetry and sending them to your SaaS backend.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here's a quick example of how to integrate <code>fastapi-guard-agent</code> into a FastAPI application.</p> <p>First, you need to configure the agent. The agent is a singleton, and you can initialize it in your application's startup event.</p> <pre><code># main.py\nimport asyncio\nfrom fastapi import FastAPI, Request\nfrom fastapi_guard.fastapi_guard import Guard\nfrom guard_agent.client import guard_agent\nfrom guard_agent.models import AgentConfig, SecurityEvent\nfrom guard_agent.utils import get_current_timestamp\n\napp = FastAPI()\n\n# 1. Configure the Guard Agent\nagent_config = AgentConfig(\n    api_key=\"YOUR_API_KEY\",\n    project_id=\"YOUR_PROJECT_ID\",\n    # Optional: fine-tune buffering and other settings\n    buffer_size=500,\n    flush_interval=60,\n)\nagent = guard_agent(agent_config)\n\n# 2. Define a custom handler to send data to the agent\nclass AgentSecurityEventHandler:\n    async def handle(self, request: Request, exc: Exception):\n        # This is a simplified example.\n        # You would create more specific events based on the exception.\n        event = SecurityEvent(\n            timestamp=get_current_timestamp(),\n            event_type=\"suspicious_request\",\n            ip_address=request.client.host,\n            endpoint=request.url.path,\n            method=request.method,\n            action_taken=\"log\",\n            reason=str(exc),\n        )\n        await agent.send_event(event)\n        # You can also re-raise the exception or return a response\n        # raise exc\n\n# 3. Configure fastapi-guard to use your handler\nguard = Guard(handlers={\"suspicious_request\": AgentSecurityEventHandler()})\n\n# 4. Use the guard in your endpoints\n@app.get(\"/\")\n@guard.protect(\"suspicious_request\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n\n# 5. Start and stop the agent with FastAPI's lifespan events\n@app.on_event(\"startup\")\nasync def startup_event():\n    # Optional: If you use Redis for buffer persistence\n    # from redis.asyncio import Redis\n    # from fastapi_guard.redis_handler import RedisHandler\n    # redis_handler = RedisHandler(redis=Redis.from_url(\"redis://localhost\"))\n    # await agent.initialize_redis(redis_handler)\n    await agent.start()\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    await agent.stop()\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Seamless Integration: Works out-of-the-box with <code>fastapi-guard</code> to collect security events and metrics.</li> <li>Asynchronous by Design: Built on <code>asyncio</code> to ensure non-blocking operations and high performance.</li> <li>Resilient Data Transport: Features a robust HTTP transport layer with automatic retries, exponential backoff, and a circuit breaker pattern for reliable data delivery.</li> <li>Efficient Buffering: Events and metrics are buffered in memory and can be persisted to Redis for durability, preventing data loss on application restarts.</li> <li>Dynamic Configuration: Can fetch dynamic security rules from the FastAPI Guard SaaS backend, allowing you to update security policies on the fly without redeploying your application.</li> <li>Extensible: Uses a protocol-based design, allowing for custom implementations of components like the transport layer or Redis handler.</li> <li>Comprehensive Telemetry: Collects detailed <code>SecurityEvent</code> and <code>SecurityMetric</code> data, providing insights into your application's security posture and performance.</li> <li>Circuit Breaker Pattern: Implements intelligent failure handling to prevent overwhelming your backend during outages.</li> <li>Rate Limiting: Built-in client-side rate limiting to ensure optimal API usage.</li> <li>Data Privacy: Configurable sensitive data redaction and payload size limits.</li> <li>Health Monitoring: Automatic agent health reporting and status tracking.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install <code>fastapi-guard-agent</code> using pip:</p> <pre><code>pip install fastapi-guard-agent\n</code></pre> <p>The agent requires Python 3.8+ and is compatible with all FastAPI versions.</p>"},{"location":"#basic-usage","title":"Basic Usage","text":""},{"location":"#simple-integration","title":"Simple Integration","text":"<p>The simplest way to get started is to configure the agent in your FastAPI application:</p> <pre><code>from fastapi import FastAPI\nfrom guard_agent.client import guard_agent\nfrom guard_agent.models import AgentConfig\n\napp = FastAPI()\n\n# Configure the agent\nconfig = AgentConfig(\n    api_key=\"your-api-key\",\n    project_id=\"your-project-id\",\n    endpoint=\"https://api.fastapi-guard.com\",\n    buffer_size=100,\n    flush_interval=30,\n)\n\n# Initialize the agent\nagent = guard_agent(config)\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    await agent.start()\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    await agent.stop()\n</code></pre>"},{"location":"#with-fastapi-guard-integration","title":"With FastAPI Guard Integration","text":"<p>For full integration with FastAPI Guard, configure the agent to receive events:</p> <pre><code>from fastapi import FastAPI, Request\nfrom fastapi_guard import Guard\nfrom guard_agent.client import guard_agent\nfrom guard_agent.models import AgentConfig, SecurityEvent\nfrom guard_agent.utils import get_current_timestamp\n\napp = FastAPI()\n\n# Configure agent\nconfig = AgentConfig(\n    api_key=\"your-api-key\",\n    project_id=\"your-project-id\",\n)\nagent = guard_agent(config)\n\n# Custom event handler for FastAPI Guard\nasync def security_event_handler(request: Request, event_type: str, reason: str):\n    \"\"\"Send security events to the agent\"\"\"\n    event = SecurityEvent(\n        timestamp=get_current_timestamp(),\n        event_type=event_type,\n        ip_address=request.client.host if request.client else \"unknown\",\n        endpoint=str(request.url.path),\n        method=request.method,\n        action_taken=\"blocked\",\n        reason=reason,\n        user_agent=request.headers.get(\"User-Agent\"),\n    )\n    await agent.send_event(event)\n\n# Configure FastAPI Guard\nguard = Guard(\n    config=SecurityConfig(\n        # ... your security config\n    ),\n    event_handler=security_event_handler,\n)\n\n@app.middleware(\"http\")\nasync def security_middleware(request: Request, call_next):\n    return await guard.process_request(request, call_next)\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    await agent.start()\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    await agent.stop()\n</code></pre>"},{"location":"#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"#redis-integration","title":"Redis Integration","text":"<p>For production deployments, enable Redis for persistent buffering:</p> <pre><code>from redis.asyncio import Redis\nfrom guard_agent.redis_handler import RedisHandler\n\n# Configure Redis\nredis_client = Redis.from_url(\"redis://localhost:6379\")\nredis_handler = RedisHandler(redis_client)\n\n# Initialize agent with Redis\nagent = guard_agent(config)\nawait agent.initialize_redis(redis_handler)\n</code></pre>"},{"location":"#custom-transport","title":"Custom Transport","text":"<p>Implement custom transport for specialized backends:</p> <pre><code>from guard_agent.protocols import TransportProtocol\nfrom guard_agent.models import SecurityEvent, SecurityMetric, AgentStatus, DynamicRules\n\nclass CustomTransport(TransportProtocol):\n    async def send_events(self, events: list[SecurityEvent]) -&gt; bool:\n        # Your custom implementation\n        return True\n\n    async def send_metrics(self, metrics: list[SecurityMetric]) -&gt; bool:\n        # Your custom implementation\n        return True\n\n    async def fetch_dynamic_rules(self) -&gt; DynamicRules | None:\n        # Your custom implementation\n        return None\n\n    async def send_status(self, status: AgentStatus) -&gt; bool:\n        # Your custom implementation\n        return True\n\n# Use custom transport\nagent = guard_agent(config)\nagent.transport = CustomTransport()\n</code></pre>"},{"location":"#data-models","title":"Data Models","text":""},{"location":"#securityevent","title":"SecurityEvent","text":"<p>Represents security-related events in your application:</p> <pre><code>from guard_agent.models import SecurityEvent\nfrom guard_agent.utils import get_current_timestamp\n\nevent = SecurityEvent(\n    timestamp=get_current_timestamp(),\n    event_type=\"ip_banned\",\n    ip_address=\"192.168.1.100\",\n    country=\"US\",\n    user_agent=\"Mozilla/5.0...\",\n    action_taken=\"block\",\n    reason=\"Rate limit exceeded\",\n    endpoint=\"/api/v1/login\",\n    method=\"POST\",\n    status_code=429,\n    response_time=0.125,\n    metadata={\"attempts\": 5, \"window\": 60}\n)\n\nawait agent.send_event(event)\n</code></pre>"},{"location":"#securitymetric","title":"SecurityMetric","text":"<p>Represents performance and usage metrics:</p> <pre><code>from guard_agent.models import SecurityMetric\n\nmetric = SecurityMetric(\n    timestamp=get_current_timestamp(),\n    metric_type=\"request_count\",\n    value=100.0,\n    endpoint=\"/api/v1/users\",\n    tags={\"method\": \"GET\", \"status\": \"200\"}\n)\n\nawait agent.send_metric(metric)\n</code></pre>"},{"location":"#dynamic-rules","title":"Dynamic Rules","text":"<p>Fetch and apply dynamic security rules from your SaaS backend:</p> <pre><code># Fetch current rules\nrules = await agent.get_dynamic_rules()\n\nif rules:\n    # Apply IP blacklist\n    if client_ip in rules.ip_blacklist:\n        # Block request\n        pass\n\n    # Apply rate limits\n    endpoint_limit = rules.endpoint_rate_limits.get(\"/api/sensitive\")\n    if endpoint_limit:\n        requests, window = endpoint_limit\n        # Apply endpoint-specific rate limit\n        pass\n\n    # Check emergency mode\n    if rules.emergency_mode:\n        # Apply stricter security measures\n        pass\n</code></pre>"},{"location":"#monitoring-and-health","title":"Monitoring and Health","text":""},{"location":"#agent-status","title":"Agent Status","text":"<p>Monitor agent health and performance:</p> <pre><code>status = await agent.get_status()\n\nprint(f\"Status: {status.status}\")  # healthy, degraded, error\nprint(f\"Uptime: {status.uptime}s\")\nprint(f\"Events sent: {status.events_sent}\")\nprint(f\"Buffer size: {status.buffer_size}\")\nprint(f\"Errors: {status.errors}\")\n</code></pre>"},{"location":"#statistics","title":"Statistics","text":"<p>Get detailed agent statistics:</p> <pre><code>stats = agent.get_stats()\n\nprint(f\"Running: {stats['running']}\")\nprint(f\"Events sent: {stats['events_sent']}\")\nprint(f\"Transport stats: {stats['transport_stats']}\")\nprint(f\"Buffer stats: {stats['buffer_stats']}\")\n</code></pre>"},{"location":"#error-handling","title":"Error Handling","text":""},{"location":"#circuit-breaker","title":"Circuit Breaker","text":"<p>The agent includes a circuit breaker to handle backend failures gracefully:</p> <pre><code># Check circuit breaker state\ntransport_stats = agent.transport.get_stats()\nif transport_stats[\"circuit_breaker_state\"] == \"OPEN\":\n    print(\"Backend is unavailable, circuit breaker is open\")\n</code></pre>"},{"location":"#retry-logic","title":"Retry Logic","text":"<p>Failed requests are automatically retried with exponential backoff:</p> <pre><code>config = AgentConfig(\n    api_key=\"your-api-key\",\n    retry_attempts=3,      # Number of retries\n    backoff_factor=1.5,    # Exponential backoff factor\n    timeout=30,            # Request timeout\n)\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Introduction</li> <li>Configuration</li> <li>Architecture</li> <li>Data Models</li> <li>Dynamic Rules</li> <li>Installation</li> <li>First Steps</li> <li>API Reference</li> </ul> <p>\ud83d\udcd6 Learn More in the Documentation</p>"},{"location":"installation/","title":"Installation","text":"<p>This guide will help you install and set up <code>fastapi-guard-agent</code> in your FastAPI application.</p>"},{"location":"installation/#requirements","title":"Requirements","text":""},{"location":"installation/#python-version","title":"Python Version","text":"<p><code>fastapi-guard-agent</code> requires Python 3.8 or higher. We recommend using Python 3.9+ for the best experience.</p> <p>You can check your Python version with:</p> <pre><code>python --version\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>The agent has the following core dependencies that will be automatically installed:</p> <ul> <li><code>fastapi</code> - FastAPI framework (any version)</li> <li><code>pydantic</code> \u2265 2.0 - Data validation and serialization</li> <li><code>httpx</code> - Async HTTP client for transport (FastAPI compatible)</li> <li><code>redis</code> \u2265 4.0.0 - Redis client for buffering (optional but recommended)</li> </ul>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<ul> <li>Redis server - For persistent event buffering (highly recommended for production)</li> <li><code>uvicorn</code> or another ASGI server - To run your FastAPI application</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#using-pip-recommended","title":"Using pip (Recommended)","text":"<p>Install the latest stable version from PyPI:</p> <pre><code>pip install fastapi-guard-agent\n</code></pre>"},{"location":"installation/#using-pip-with-specific-version","title":"Using pip with specific version","text":"<p>If you need a specific version:</p> <pre><code>pip install fastapi-guard-agent==0.1.1\n</code></pre>"},{"location":"installation/#using-poetry","title":"Using Poetry","text":"<p>If you're using Poetry for dependency management:</p> <pre><code>poetry add fastapi-guard-agent\n</code></pre>"},{"location":"installation/#using-pip-tools","title":"Using pip-tools","text":"<p>Add to your <code>requirements.in</code>:</p> <pre><code>fastapi-guard-agent\n</code></pre> <p>Then compile and install:</p> <pre><code>pip-compile requirements.in\npip install -r requirements.txt\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute or install from source:</p> <pre><code>git clone https://github.com/rennf93/fastapi-guard-agent.git\ncd fastapi-guard-agent\npip install -e .\n</code></pre>"},{"location":"installation/#docker-installation","title":"Docker Installation","text":"<p>You can also use the agent in a Docker environment. Add it to your <code>Dockerfile</code>:</p> <pre><code>FROM python:3.11-slim\n\n# Install the agent\nRUN pip install fastapi-guard-agent\n\n# Copy your application\nCOPY . /app\nWORKDIR /app\n\n# Install your app dependencies\nRUN pip install -r requirements.txt\n\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>After installation, verify that the agent is correctly installed:</p>"},{"location":"installation/#1-import-test","title":"1. Import Test","text":"<pre><code># test_installation.py\ntry:\n    from guard_agent import __version__\n    from guard_agent.client import guard_agent\n    from guard_agent.models import AgentConfig\n    print(f\"\u2705 FastAPI Guard Agent {__version__} installed successfully!\")\nexcept ImportError as e:\n    print(f\"\u274c Installation failed: {e}\")\n</code></pre> <p>Run the test:</p> <pre><code>python test_installation.py\n</code></pre>"},{"location":"installation/#2-basic-configuration-test","title":"2. Basic Configuration Test","text":"<pre><code># test_config.py\nfrom guard_agent.client import guard_agent\nfrom guard_agent.models import AgentConfig\n\ntry:\n    config = AgentConfig(\n        api_key=\"test-key\",\n        project_id=\"test-project\"\n    )\n    agent = guard_agent(config)\n    print(\"\u2705 Agent configuration successful!\")\nexcept Exception as e:\n    print(f\"\u274c Configuration failed: {e}\")\n</code></pre>"},{"location":"installation/#3-redis-connection-test-optional","title":"3. Redis Connection Test (Optional)","text":"<p>If you're planning to use Redis for buffering:</p> <pre><code># test_redis.py\nimport asyncio\nfrom redis.asyncio import Redis\n\nasync def test_redis():\n    try:\n        redis = Redis.from_url(\"redis://localhost:6379\")\n        await redis.ping()\n        print(\"\u2705 Redis connection successful!\")\n    except Exception as e:\n        print(f\"\u274c Redis connection failed: {e}\")\n    finally:\n        await redis.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(test_redis())\n</code></pre>"},{"location":"installation/#configuration-verification","title":"Configuration Verification","text":"<p>Create a minimal configuration to ensure everything works:</p> <pre><code># minimal_test.py\nimport asyncio\nfrom guard_agent.client import guard_agent\nfrom guard_agent.models import AgentConfig\n\nasync def test_agent():\n    config = AgentConfig(\n        api_key=\"your-test-api-key\",\n        project_id=\"your-test-project\",\n        endpoint=\"https://api.fastapi-guard.com\"  # or your custom endpoint\n    )\n\n    agent = guard_agent(config)\n\n    # Test agent lifecycle\n    try:\n        await agent.start()\n        print(\"\u2705 Agent started successfully!\")\n\n        # Check agent status\n        status = await agent.get_status()\n        print(f\"\u2705 Agent status: {status.status}\")\n\n    except Exception as e:\n        print(f\"\u274c Agent test failed: {e}\")\n    finally:\n        await agent.stop()\n        print(\"\u2705 Agent stopped successfully!\")\n\nif __name__ == \"__main__\":\n    asyncio.run(test_agent())\n</code></pre>"},{"location":"installation/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"installation/#import-errors","title":"Import Errors","text":"<p>Problem: <code>ModuleNotFoundError: No module named 'guard_agent'</code></p> <p>Solutions: 1. Ensure you're using the correct Python environment:    <pre><code>which python\npip list | grep fastapi-guard-agent\n</code></pre></p> <ol> <li> <p>If using virtual environments, make sure it's activated:    <pre><code>source venv/bin/activate  # Linux/Mac\n# or\nvenv\\Scripts\\activate     # Windows\n</code></pre></p> </li> <li> <p>Reinstall the package:    <pre><code>pip uninstall fastapi-guard-agent\npip install fastapi-guard-agent\n</code></pre></p> </li> </ol>"},{"location":"installation/#redis-connection-issues","title":"Redis Connection Issues","text":"<p>Problem: <code>ConnectionError: Error connecting to Redis</code></p> <p>Solutions: 1. Ensure Redis server is running:    <pre><code>redis-cli ping\n</code></pre></p> <ol> <li> <p>Check Redis configuration in your agent config:    <pre><code># Make sure Redis URL is correct\nredis = Redis.from_url(\"redis://localhost:6379/0\")\n</code></pre></p> </li> <li> <p>Install Redis server if not installed:    <pre><code># Ubuntu/Debian\nsudo apt-get install redis-server\n\n# macOS with Homebrew\nbrew install redis\n\n# Start Redis\nredis-server\n</code></pre></p> </li> </ol>"},{"location":"installation/#http-transport-issues","title":"HTTP Transport Issues","text":"<p>Problem: <code>httpx.HTTPError</code> or connection timeouts</p> <p>Solutions: 1. Check your API endpoint configuration:    <pre><code>config = AgentConfig(\n    endpoint=\"https://api.fastapi-guard.com\",  # Ensure this is correct\n    api_key=\"your-api-key\"\n)\n</code></pre></p> <ol> <li> <p>Verify network connectivity:    <pre><code>curl -I https://api.fastapi-guard.com/health\n</code></pre></p> </li> <li> <p>Check firewall settings and proxy configuration if behind corporate network.</p> </li> </ol>"},{"location":"installation/#permission-issues","title":"Permission Issues","text":"<p>Problem: <code>PermissionError</code> during installation</p> <p>Solutions: 1. Use <code>--user</code> flag for user-level installation:    <pre><code>pip install --user fastapi-guard-agent\n</code></pre></p> <ol> <li> <p>Use virtual environment (recommended):    <pre><code>python -m venv venv\nsource venv/bin/activate\npip install fastapi-guard-agent\n</code></pre></p> </li> <li> <p>On systems with permission issues, consider using <code>sudo</code> (not recommended):    <pre><code>sudo pip install fastapi-guard-agent\n</code></pre></p> </li> </ol>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>Once you have successfully installed <code>fastapi-guard-agent</code>, you can:</p> <ol> <li>Get Started - Follow our quick start guide</li> <li>Configure the Agent - Learn about configuration options</li> <li>Integrate with FastAPI Guard - Full integration guide</li> <li>Explore Examples - See real-world usage examples</li> </ol>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues not covered here:</p> <ol> <li>Check our Troubleshooting Guide</li> <li>Search existing GitHub Issues</li> <li>Create a new issue with:</li> <li>Your Python version (<code>python --version</code>)</li> <li>Package version (<code>pip show fastapi-guard-agent</code>)</li> <li>Error message and full traceback</li> <li>Your configuration (with sensitive data removed)</li> </ol>"},{"location":"installation/#system-requirements-summary","title":"System Requirements Summary","text":"Component Requirement Python 3.8+ (3.9+ recommended) Memory 64MB+ available RAM Network HTTPS outbound access Storage 10MB+ disk space Redis Optional but recommended for production"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#v011-2025-07-09","title":"v0.1.1 (2025-07-09)","text":""},{"location":"release-notes/#enhancements-v011","title":"Enhancements (v0.1.1)","text":"<ul> <li>Standardized Redis Protocl/Manager methods across libraries.</li> </ul>"},{"location":"release-notes/#v010-2025-07-08","title":"v0.1.0 (2025-07-08)","text":""},{"location":"release-notes/#enhancements-v010","title":"Enhancements (v0.1.0)","text":"<ul> <li>Switched from aiohttp to httpx for HTTP client.</li> <li>Completed implementation.</li> <li>100% test coverage.</li> </ul>"},{"location":"release-notes/#v001-2025-06-22","title":"v0.0.1 (2025-06-22)","text":""},{"location":"release-notes/#new-features-v001","title":"New Features (v0.0.1)","text":"<ul> <li>Initial release FastAPI Guard Agent.</li> </ul>"},{"location":"api/overview/","title":"API Overview","text":"<p>FastAPI Guard Agent provides a clean, extensible API for collecting and transmitting security events and metrics from your FastAPI Guard implementation to monitoring backends.</p>"},{"location":"api/overview/#architecture-overview","title":"Architecture Overview","text":"<p>The agent follows a modular, protocol-based architecture designed for reliability, performance, and extensibility:</p> <pre><code>graph TB\n    subgraph \"FastAPI Application\"\n        FG[FastAPI Guard&lt;br/&gt;Middleware]\n    end\n\n    subgraph \"FastAPI Guard Agent\"\n        AH[Agent Handler&lt;br/&gt;\ud83c\udfaf Central coordinator]\n        EB[Event Buffer&lt;br/&gt;\ud83d\udcca Temporary storage]\n        TR[HTTP Transport&lt;br/&gt;\ud83d\ude80 Network layer]\n\n        subgraph \"Protocols\"\n            BP[Buffer Protocol]\n            TP[Transport Protocol]\n            RP[Redis Protocol]\n            AP[Agent Protocol]\n        end\n    end\n\n    subgraph \"Storage &amp; Network\"\n        RD[(Redis&lt;br/&gt;\ud83d\udcbe Persistence)]\n        BE[Backend Service&lt;br/&gt;\u2601\ufe0f Your monitoring system]\n    end\n\n    FG --&gt; AH\n    AH --&gt; EB\n    EB --&gt; TR\n    EB -.-&gt; RD\n    TR --&gt; BE\n\n    AH -.-&gt; BP\n    AH -.-&gt; TP\n    EB -.-&gt; RP\n    AH -.-&gt; AP\n</code></pre>"},{"location":"api/overview/#core-components","title":"Core Components","text":""},{"location":"api/overview/#1-agent-handler-guardagenthandler","title":"1. Agent Handler (<code>GuardAgentHandler</code>)","text":"<p>The central coordinator that manages the entire agent lifecycle.</p> <p>Key Responsibilities: - \ud83c\udfaf Lifecycle Management: Start, stop, and health monitoring - \ud83d\udd04 Event Processing: Receives events from FastAPI Guard - \ud83d\udcca Metric Collection: Gathers performance and security metrics - \ud83d\udd79\ufe0f Background Tasks: Manages flushing, status updates, and rule fetching</p> <p>Basic Usage: <pre><code>from guard_agent import GuardAgentHandler\nfrom guard_agent.models import AgentConfig\n\n# Initialize\nconfig = AgentConfig(\n    backend_url=\"https://your-backend.com\",\n    api_key=\"your-api-key\"\n)\nhandler = GuardAgentHandler(config)\n\n# Lifecycle\nawait handler.start()\nawait handler.stop()\n\n# Send data\nawait handler.send_event(security_event)\nawait handler.send_metric(performance_metric)\n</code></pre></p>"},{"location":"api/overview/#2-event-buffer-eventbuffer","title":"2. Event Buffer (<code>EventBuffer</code>)","text":"<p>Intelligent buffering system with persistence and auto-flushing capabilities.</p> <p>Key Features: - \ud83d\udcca Deque-based Storage: Efficient in-memory buffering - \ud83d\udcbe Redis Persistence: Optional persistent storage - \u23f0 Auto-flushing: Time and size-based triggers - \ud83d\udd12 Thread Safety: Async-safe operations</p> <p>Usage Patterns: <pre><code>from guard_agent.buffer import EventBuffer\nfrom guard_agent.models import SecurityEvent\n\n# Create buffer\nbuffer = EventBuffer(\n    max_size=1000,\n    flush_interval=60,\n    redis_handler=redis_client  # optional\n)\n\n# Add events\nawait buffer.add_event(security_event)\nawait buffer.add_metric(performance_metric)\n\n# Manual flush\nevents, metrics = await buffer.flush()\n</code></pre></p>"},{"location":"api/overview/#3-http-transport-httptransport","title":"3. HTTP Transport (<code>HTTPTransport</code>)","text":"<p>Resilient HTTP client with enterprise-grade reliability features.</p> <p>Key Features: - \ud83d\udd04 Retry Logic: Exponential backoff with jitter - \u26a1 Circuit Breaker: Prevents cascade failures - \ud83d\udea6 Rate Limiting: Configurable request throttling - \ud83d\udcca Statistics: Detailed performance metrics</p> <p>Configuration: <pre><code>from guard_agent.transport import HTTPTransport\n\ntransport = HTTPTransport(\n    backend_url=\"https://your-backend.com\",\n    api_key=\"your-api-key\",\n    timeout=30,\n    max_retries=3,\n    backoff_factor=2.0,\n    rate_limit_requests=100,\n    rate_limit_period=60\n)\n</code></pre></p>"},{"location":"api/overview/#4-data-models","title":"4. Data Models","text":"<p>Type-safe Pydantic models for all data structures.</p> <p>Core Models: - <code>AgentConfig</code>: Agent configuration and settings - <code>SecurityEvent</code>: Security incidents and violations - <code>SecurityMetric</code>: Performance and telemetry data - <code>EventBatch</code>: Batch container for efficient transmission - <code>AgentStatus</code>: Real-time agent health information</p>"},{"location":"api/overview/#5-protocol-system","title":"5. Protocol System","text":"<p>Extensible protocol definitions for custom implementations.</p> <p>Available Protocols: - <code>AgentHandlerProtocol</code>: Agent handler interface - <code>BufferProtocol</code>: Buffer implementation interface - <code>TransportProtocol</code>: Transport layer interface - <code>RedisHandlerProtocol</code>: Redis integration interface</p>"},{"location":"api/overview/#api-reference-by-module","title":"API Reference by Module","text":""},{"location":"api/overview/#core-handler-api","title":"Core Handler API","text":""},{"location":"api/overview/#guardagenthandler","title":"<code>GuardAgentHandler</code>","text":"<p>The main entry point for all agent operations.</p> <pre><code>class GuardAgentHandler:\n    def __init__(self, config: AgentConfig) -&gt; None: ...\n\n    # Lifecycle Management\n    async def start(self) -&gt; None: ...\n    async def stop(self) -&gt; None: ...\n    async def is_running(self) -&gt; bool: ...\n\n    # Event &amp; Metric Handling\n    async def send_event(self, event: SecurityEvent) -&gt; None: ...\n    async def send_metric(self, metric: SecurityMetric) -&gt; None: ...\n\n    # Status &amp; Health\n    async def get_status(self) -&gt; AgentStatus: ...\n    async def health_check(self) -&gt; bool: ...\n\n    # Configuration\n    async def update_config(self, config: AgentConfig) -&gt; None: ...\n    async def get_dynamic_rules(self) -&gt; DynamicRules: ...\n</code></pre> <p>Key Methods:</p> Method Description Usage <code>start()</code> Initialize agent and start background tasks Called on app startup <code>stop()</code> Graceful shutdown with data preservation Called on app shutdown <code>send_event()</code> Send security event to buffer Auto-called by FastAPI Guard <code>send_metric()</code> Send performance metric Manual or auto collection <code>get_status()</code> Get real-time agent status Health monitoring"},{"location":"api/overview/#buffer-api","title":"Buffer API","text":""},{"location":"api/overview/#eventbuffer","title":"<code>EventBuffer</code>","text":"<p>Intelligent event and metric buffering with persistence.</p> <pre><code>class EventBuffer:\n    def __init__(\n        self,\n        max_size: int = 1000,\n        flush_interval: int = 60,\n        redis_handler: Optional[RedisHandlerProtocol] = None\n    ) -&gt; None: ...\n\n    # Data Management\n    async def add_event(self, event: SecurityEvent) -&gt; None: ...\n    async def add_metric(self, metric: SecurityMetric) -&gt; None: ...\n    async def flush(self) -&gt; Tuple[List[SecurityEvent], List[SecurityMetric]]: ...\n\n    # Status &amp; Configuration\n    def get_stats(self) -&gt; Dict[str, Any]: ...\n    async def clear(self) -&gt; None: ...\n    def is_full(self) -&gt; bool: ...\n</code></pre>"},{"location":"api/overview/#transport-api","title":"Transport API","text":""},{"location":"api/overview/#httptransport","title":"<code>HTTPTransport</code>","text":"<p>Enterprise-grade HTTP client with resilience features.</p> <pre><code>class HTTPTransport:\n    def __init__(\n        self,\n        backend_url: str,\n        api_key: str,\n        timeout: int = 30,\n        max_retries: int = 3,\n        backoff_factor: float = 2.0\n    ) -&gt; None: ...\n\n    # Data Transmission\n    async def send_batch(self, batch: EventBatch) -&gt; bool: ...\n    async def send_heartbeat(self, status: AgentStatus) -&gt; bool: ...\n\n    # Health &amp; Status\n    async def test_connection(self) -&gt; bool: ...\n    def get_stats(self) -&gt; TransportStats: ...\n\n    # Configuration\n    async def update_rules(self) -&gt; Optional[DynamicRules]: ...\n</code></pre>"},{"location":"api/overview/#models-api","title":"Models API","text":""},{"location":"api/overview/#core-data-models","title":"Core Data Models","text":"<p>AgentConfig <pre><code>class AgentConfig(BaseModel):\n    backend_url: str\n    api_key: str\n    buffer_size: int = 1000\n    flush_interval: int = 60\n    enabled: bool = True\n    # ... additional fields\n</code></pre></p> <p>SecurityEvent <pre><code>class SecurityEvent(BaseModel):\n    event_type: EventType\n    source_ip: str\n    timestamp: datetime\n    description: str\n    metadata: Optional[Dict[str, Any]] = None\n    # ... additional fields\n</code></pre></p> <p>SecurityMetric <pre><code>class SecurityMetric(BaseModel):\n    metric_type: MetricType\n    value: Union[int, float]\n    timestamp: datetime\n    metadata: Optional[Dict[str, Any]] = None\n    # ... additional fields\n</code></pre></p>"},{"location":"api/overview/#common-usage-patterns","title":"Common Usage Patterns","text":""},{"location":"api/overview/#pattern-1-basic-integration","title":"Pattern 1: Basic Integration","text":"<pre><code>from fastapi import FastAPI\nfrom guard import SecurityMiddleware\nfrom guard_agent import GuardAgentHandler\nfrom guard_agent.models import AgentConfig\n\napp = FastAPI()\n\n# Configure agent\nconfig = AgentConfig(\n    backend_url=\"https://your-backend.com\",\n    api_key=\"your-api-key\"\n)\nagent = GuardAgentHandler(config)\n\n# Add to middleware\nmiddleware_config = SecurityMiddleware.Config(\n    agent_handler=agent\n)\napp.add_middleware(SecurityMiddleware, config=middleware_config)\n\n@app.on_event(\"startup\")\nasync def startup():\n    await agent.start()\n\n@app.on_event(\"shutdown\")\nasync def shutdown():\n    await agent.stop()\n</code></pre>"},{"location":"api/overview/#pattern-2-custom-event-processing","title":"Pattern 2: Custom Event Processing","text":"<pre><code>from guard_agent.models import SecurityEvent, EventType\n\nasync def custom_security_check(request):\n    \"\"\"Custom security validation with event reporting.\"\"\"\n\n    # Your custom logic\n    if is_suspicious(request):\n        # Create custom event\n        event = SecurityEvent(\n            event_type=EventType.CUSTOM,\n            source_ip=get_client_ip(request),\n            description=\"Custom security check failed\",\n            metadata={\n                \"check_type\": \"business_logic\",\n                \"details\": get_check_details()\n            }\n        )\n\n        # Send to agent\n        await agent.send_event(event)\n\n        return False\n\n    return True\n</code></pre>"},{"location":"api/overview/#pattern-3-performance-monitoring","title":"Pattern 3: Performance Monitoring","text":"<pre><code>from guard_agent.models import SecurityMetric, MetricType\nimport time\n\nasync def monitor_endpoint_performance():\n    \"\"\"Monitor endpoint performance and send metrics.\"\"\"\n\n    start_time = time.time()\n\n    try:\n        # Your endpoint logic\n        result = await process_request()\n\n        # Success metric\n        await agent.send_metric(SecurityMetric(\n            metric_type=MetricType.RESPONSE_TIME,\n            value=time.time() - start_time,\n            metadata={\"status\": \"success\"}\n        ))\n\n        return result\n\n    except Exception as e:\n        # Error metric\n        await agent.send_metric(SecurityMetric(\n            metric_type=MetricType.ERROR_COUNT,\n            value=1,\n            metadata={\"error\": str(e)}\n        ))\n        raise\n</code></pre>"},{"location":"api/overview/#pattern-4-health-monitoring","title":"Pattern 4: Health Monitoring","text":"<pre><code>@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Application health check including agent status.\"\"\"\n\n    agent_healthy = await agent.health_check()\n    agent_status = await agent.get_status()\n\n    return {\n        \"status\": \"healthy\" if agent_healthy else \"degraded\",\n        \"agent\": {\n            \"running\": agent_status.is_running,\n            \"events_processed\": agent_status.events_processed,\n            \"last_flush\": agent_status.last_flush_time,\n            \"buffer_size\": agent_status.buffer_size\n        }\n    }\n</code></pre>"},{"location":"api/overview/#error-handling","title":"Error Handling","text":""},{"location":"api/overview/#graceful-degradation","title":"Graceful Degradation","text":"<p>The agent is designed to fail gracefully without affecting your application:</p> <pre><code>try:\n    await agent.send_event(event)\nexcept Exception as e:\n    # Agent failure doesn't break your app\n    logger.warning(f\"Agent error: {e}\")\n    # Application continues normally\n</code></pre>"},{"location":"api/overview/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<p>The HTTP transport includes a circuit breaker to prevent cascade failures:</p> <pre><code># Circuit breaker states:\n# - CLOSED: Normal operation\n# - OPEN: Failing fast, not attempting requests\n# - HALF_OPEN: Testing if service is back\n</code></pre>"},{"location":"api/overview/#retry-strategies","title":"Retry Strategies","text":"<p>Built-in retry logic with exponential backoff:</p> <pre><code># Retry configuration\nmax_retries: 3\nbackoff_factor: 2.0  # 1s, 2s, 4s delays\njitter: True  # Add randomness to prevent thundering herd\n</code></pre>"},{"location":"api/overview/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/overview/#memory-usage","title":"Memory Usage","text":"<ul> <li>Buffer Size: Configure based on your traffic volume</li> <li>Flush Frequency: Balance between real-time data and efficiency</li> <li>Redis Usage: Optional for high-volume scenarios</li> </ul>"},{"location":"api/overview/#network-efficiency","title":"Network Efficiency","text":"<ul> <li>Batching: Events are sent in batches to reduce overhead</li> <li>Compression: HTTP transport supports gzip compression</li> <li>Keep-Alive: Connection pooling for better performance</li> </ul>"},{"location":"api/overview/#resource-management","title":"Resource Management","text":"<pre><code># Example configuration for different scales\n# Small application\nconfig = AgentConfig(buffer_size=100, flush_interval=30)\n\n# Medium application\nconfig = AgentConfig(buffer_size=1000, flush_interval=60)\n\n# High-volume application\nconfig = AgentConfig(buffer_size=5000, flush_interval=120)\n</code></pre>"},{"location":"api/overview/#next-steps","title":"Next Steps","text":"<ul> <li>\ud83d\udcd6 Agent Handler API - Detailed handler documentation</li> <li>\ud83d\udcca Event Buffer API - Buffer management details</li> <li>\ud83d\ude80 Transport API - HTTP transport configuration</li> <li>\ud83c\udfd7\ufe0f Models API - Complete data model reference</li> <li>\ud83d\udd0c Protocols API - Extension interfaces</li> <li>\ud83d\udee0\ufe0f Utilities API - Helper functions and tools</li> </ul>"},{"location":"api/overview/#support","title":"Support","text":"<p>For detailed implementation examples and advanced patterns, see:</p> <ul> <li>\ud83d\udcda Examples - Practical implementation examples</li> <li>\ud83d\udcd6 Integration Guide - Advanced integration patterns</li> <li>\ud83d\udd27 Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"tutorial/getting-started/","title":"Getting Started","text":"<p>This tutorial will guide you through setting up and using <code>fastapi-guard-agent</code> in your FastAPI application. By the end of this guide, you'll have a working integration that collects security events and metrics from your application.</p>"},{"location":"tutorial/getting-started/#overview","title":"Overview","text":"<p>The FastAPI Guard Agent is a companion library to <code>fastapi-guard</code> that:</p> <ol> <li>Collects security events and performance metrics from your FastAPI application</li> <li>Buffers this data efficiently in memory (and optionally in Redis)</li> <li>Transmits the data reliably to the FastAPI Guard SaaS backend</li> <li>Fetches dynamic security rules to keep your application protection up-to-date</li> </ol>"},{"location":"tutorial/getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>Python 3.8+ installed</li> <li><code>fastapi-guard-agent</code> installed (Installation Guide)</li> <li>FastAPI application (existing or new)</li> <li>API credentials from the FastAPI Guard SaaS platform</li> <li>Redis server (optional but recommended for production)</li> </ul>"},{"location":"tutorial/getting-started/#step-by-step-setup","title":"Step-by-Step Setup","text":""},{"location":"tutorial/getting-started/#step-1-basic-agent-configuration","title":"Step 1: Basic Agent Configuration","text":"<p>First, let's create a minimal FastAPI application with the agent configured:</p> <pre><code># main.py\nfrom fastapi import FastAPI\nfrom guard_agent.client import guard_agent\nfrom guard_agent.models import AgentConfig\n\napp = FastAPI(title=\"My Secure API\")\n\n# Configure the Guard Agent\nconfig = AgentConfig(\n    api_key=\"your-api-key-here\",           # Replace with your actual API key\n    project_id=\"your-project-id\",          # Replace with your project ID\n    endpoint=\"https://api.fastapi-guard.com\",  # Default SaaS endpoint\n    buffer_size=100,                       # Buffer up to 100 events\n    flush_interval=30,                     # Send data every 30 seconds\n    enable_events=True,                    # Enable security event collection\n    enable_metrics=True,                   # Enable performance metrics\n)\n\n# Initialize the agent (singleton pattern)\nagent = guard_agent(config)\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello, World!\"}\n\n@app.get(\"/health\")\nasync def health():\n    return {\"status\": \"healthy\"}\n\n# Lifecycle management\n@app.on_event(\"startup\")\nasync def startup_event():\n    \"\"\"Start the agent when the application starts.\"\"\"\n    await agent.start()\n    print(\"\ud83d\ude80 FastAPI Guard Agent started successfully!\")\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    \"\"\"Stop the agent when the application shuts down.\"\"\"\n    await agent.stop()\n    print(\"\ud83d\uded1 FastAPI Guard Agent stopped successfully!\")\n</code></pre>"},{"location":"tutorial/getting-started/#step-2-understanding-configuration-options","title":"Step 2: Understanding Configuration Options","text":"<p>The <code>AgentConfig</code> model provides several configuration options:</p> <pre><code>from guard_agent.models import AgentConfig\n\nconfig = AgentConfig(\n    # Required settings\n    api_key=\"your-api-key\",               # Your SaaS platform API key\n    project_id=\"your-project-id\",         # Your project identifier\n\n    # Optional settings with defaults\n    endpoint=\"https://api.fastapi-guard.com\",  # SaaS platform endpoint\n    buffer_size=100,                      # Max events in memory buffer\n    flush_interval=30,                    # Seconds between data transmissions\n    enable_events=True,                   # Collect security events\n    enable_metrics=True,                  # Collect performance metrics\n    max_payload_size=1024 * 1024,        # Max size for single payload (1MB)\n    retry_attempts=3,                     # HTTP retry attempts\n    retry_delay=1.0,                      # Initial retry delay (seconds)\n    timeout=30.0,                         # HTTP request timeout\n)\n</code></pre>"},{"location":"tutorial/getting-started/#step-3-understanding-data-flow","title":"Step 3: Understanding Data Flow","text":"<p>Here's how data flows through the agent:</p> <pre><code>graph TD\n    A[FastAPI App] --&gt; B[Security Event]\n    A --&gt; C[Performance Metric]\n    B --&gt; D[Event Buffer]\n    C --&gt; D\n    D --&gt; E{Buffer Full?}\n    E --&gt;|Yes| F[HTTP Transport]\n    E --&gt;|No| G[Wait for Interval]\n    G --&gt; E\n    F --&gt; H[SaaS Backend]\n    H --&gt; I[Dynamic Rules]\n    I --&gt; A\n</code></pre> <p>Data Flow Explanation:</p> <ol> <li>Event Generation: Your FastAPI application generates security events and metrics</li> <li>Buffering: The agent buffers this data in memory (and optionally Redis)</li> <li>Transmission: When the buffer fills up or the flush interval expires, data is sent</li> <li>Processing: The SaaS backend processes the data and may return updated rules</li> <li>Rule Updates: Dynamic security rules are applied to your application</li> </ol>"},{"location":"tutorial/getting-started/#step-4-monitoring-events","title":"Step 4: Monitoring Events","text":"<p>To see the agent in action, let's add some basic monitoring:</p> <pre><code># enhanced_main.py\nimport asyncio\nfrom fastapi import FastAPI, Request, HTTPException\nfrom guard_agent.client import guard_agent\nfrom guard_agent.models import AgentConfig, SecurityEvent, SecurityMetric\nfrom guard_agent.utils import get_current_timestamp\n\napp = FastAPI(title=\"My Secure API with Monitoring\")\n\n# Configure the agent\nconfig = AgentConfig(\n    api_key=\"your-api-key-here\",\n    project_id=\"your-project-id\",\n    buffer_size=50,                        # Smaller buffer for testing\n    flush_interval=10,                     # More frequent flushes for testing\n)\n\nagent = guard_agent(config)\n\n@app.middleware(\"http\")\nasync def security_monitoring_middleware(request: Request, call_next):\n    \"\"\"Middleware to monitor requests and generate events.\"\"\"\n    start_time = get_current_timestamp()\n\n    # Process the request\n    response = await call_next(request)\n\n    # Calculate response time\n    end_time = get_current_timestamp()\n    response_time = (end_time - start_time) * 1000  # Convert to milliseconds\n\n    # Create a performance metric\n    metric = SecurityMetric(\n        timestamp=end_time,\n        metric_type=\"response_time\",\n        value=response_time,\n        metadata={\n            \"endpoint\": request.url.path,\n            \"method\": request.method,\n            \"status_code\": response.status_code,\n            \"ip_address\": request.client.host,\n        }\n    )\n\n    # Send the metric to the agent\n    await agent.send_metric(metric)\n\n    # Example: Generate security event for certain conditions\n    if response.status_code &gt;= 400:\n        event = SecurityEvent(\n            timestamp=end_time,\n            event_type=\"error_response\",\n            ip_address=request.client.host,\n            endpoint=request.url.path,\n            method=request.method,\n            action_taken=\"log\",\n            reason=f\"HTTP {response.status_code} response\",\n            metadata={\n                \"user_agent\": request.headers.get(\"user-agent\", \"\"),\n                \"response_time_ms\": response_time,\n            }\n        )\n        await agent.send_event(event)\n\n    return response\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello, World!\", \"timestamp\": get_current_timestamp()}\n\n@app.get(\"/error\")\nasync def trigger_error():\n    \"\"\"Endpoint to test error event generation.\"\"\"\n    raise HTTPException(status_code=400, detail=\"This is a test error\")\n\n@app.get(\"/slow\")\nasync def slow_endpoint():\n    \"\"\"Endpoint to test performance monitoring.\"\"\"\n    await asyncio.sleep(2)  # Simulate slow operation\n    return {\"message\": \"This was a slow operation\"}\n\n@app.get(\"/agent/status\")\nasync def get_agent_status():\n    \"\"\"Get the current status of the Guard Agent.\"\"\"\n    status = await agent.get_status()\n    return {\n        \"agent_status\": status.status,\n        \"events_sent\": status.events_sent,\n        \"metrics_sent\": status.metrics_sent,\n        \"last_flush\": status.last_flush,\n        \"buffer_size\": status.buffer_size,\n    }\n\n# Lifecycle management\n@app.on_event(\"startup\")\nasync def startup_event():\n    await agent.start()\n    print(\"\ud83d\ude80 FastAPI Guard Agent started with monitoring!\")\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    await agent.stop()\n    print(\"\ud83d\uded1 FastAPI Guard Agent stopped!\")\n</code></pre>"},{"location":"tutorial/getting-started/#step-5-testing-your-setup","title":"Step 5: Testing Your Setup","text":"<p>Now let's test the integration:</p> <ol> <li> <p>Start your application:    <pre><code>uvicorn main:app --reload\n</code></pre></p> </li> <li> <p>Make some test requests:    <pre><code># Normal request\ncurl http://localhost:8000/\n\n# Trigger an error event\ncurl http://localhost:8000/error\n\n# Trigger a slow response metric\ncurl http://localhost:8000/slow\n\n# Check agent status\ncurl http://localhost:8000/agent/status\n</code></pre></p> </li> <li> <p>Monitor the logs: You should see output like:    <pre><code>\ud83d\ude80 FastAPI Guard Agent started with monitoring!\nINFO:     Application startup complete.\n</code></pre></p> </li> <li> <p>Check agent status: Visit <code>http://localhost:8000/agent/status</code> to see:    <pre><code>{\n  \"agent_status\": \"running\",\n  \"events_sent\": 5,\n  \"metrics_sent\": 12,\n  \"last_flush\": 1677123456.789,\n  \"buffer_size\": 3\n}\n</code></pre></p> </li> </ol>"},{"location":"tutorial/getting-started/#common-patterns","title":"Common Patterns","text":""},{"location":"tutorial/getting-started/#development-vs-production-configuration","title":"Development vs Production Configuration","text":"<p>Development Configuration: <pre><code># config_dev.py\nfrom guard_agent.models import AgentConfig\n\ndev_config = AgentConfig(\n    api_key=\"dev-api-key\",\n    project_id=\"my-app-dev\",\n    buffer_size=10,                # Small buffer for immediate feedback\n    flush_interval=5,              # Frequent flushes for testing\n    enable_events=True,\n    enable_metrics=True,\n)\n</code></pre></p> <p>Production Configuration: <pre><code># config_prod.py\nfrom guard_agent.models import AgentConfig\n\nprod_config = AgentConfig(\n    api_key=\"prod-api-key\",\n    project_id=\"my-app-prod\",\n    buffer_size=500,               # Larger buffer for efficiency\n    flush_interval=60,             # Less frequent flushes\n    enable_events=True,\n    enable_metrics=True,\n    retry_attempts=5,              # More retries for reliability\n    timeout=60.0,                  # Longer timeout for stability\n)\n</code></pre></p>"},{"location":"tutorial/getting-started/#error-handling","title":"Error Handling","text":"<p>Always include proper error handling:</p> <pre><code>@app.on_event(\"startup\")\nasync def startup_event():\n    try:\n        await agent.start()\n        print(\"\u2705 Guard Agent started successfully\")\n    except Exception as e:\n        print(f\"\u274c Failed to start Guard Agent: {e}\")\n        # Decide whether to continue without the agent or exit\n        # For critical applications, you might want to exit:\n        # import sys; sys.exit(1)\n\n@app.middleware(\"http\")\nasync def safe_monitoring_middleware(request: Request, call_next):\n    response = await call_next(request)\n\n    try:\n        # Your monitoring logic here\n        await agent.send_metric(metric)\n    except Exception as e:\n        # Log the error but don't fail the request\n        print(f\"Warning: Failed to send metric: {e}\")\n\n    return response\n</code></pre>"},{"location":"tutorial/getting-started/#custom-event-processing","title":"Custom Event Processing","text":"<p>Create custom event processors for specific use cases:</p> <pre><code>from guard_agent.models import SecurityEvent\nfrom guard_agent.utils import get_current_timestamp\n\nclass CustomSecurityEventProcessor:\n    def __init__(self, agent):\n        self.agent = agent\n\n    async def process_login_attempt(self, request: Request, success: bool, user_id: str = None):\n        \"\"\"Process login attempt events.\"\"\"\n        event = SecurityEvent(\n            timestamp=get_current_timestamp(),\n            event_type=\"login_attempt\",\n            ip_address=request.client.host,\n            endpoint=\"/auth/login\",\n            method=\"POST\",\n            action_taken=\"log\" if success else \"block\",\n            reason=\"successful_login\" if success else \"failed_login\",\n            metadata={\n                \"user_id\": user_id,\n                \"user_agent\": request.headers.get(\"user-agent\", \"\"),\n                \"success\": success,\n            }\n        )\n        await self.agent.send_event(event)\n\n    async def process_suspicious_activity(self, request: Request, activity_type: str, severity: str):\n        \"\"\"Process suspicious activity events.\"\"\"\n        event = SecurityEvent(\n            timestamp=get_current_timestamp(),\n            event_type=\"suspicious_activity\",\n            ip_address=request.client.host,\n            endpoint=request.url.path,\n            method=request.method,\n            action_taken=\"log\" if severity == \"low\" else \"alert\",\n            reason=activity_type,\n            metadata={\n                \"severity\": severity,\n                \"user_agent\": request.headers.get(\"user-agent\", \"\"),\n            }\n        )\n        await self.agent.send_event(event)\n\n# Usage\nprocessor = CustomSecurityEventProcessor(agent)\n\n@app.post(\"/auth/login\")\nasync def login(request: Request, credentials: LoginCredentials):\n    # Your login logic here\n    success = authenticate_user(credentials)\n\n    # Process the login event\n    await processor.process_login_attempt(\n        request,\n        success,\n        user_id=credentials.username if success else None\n    )\n\n    return {\"success\": success}\n</code></pre>"},{"location":"tutorial/getting-started/#integration-testing","title":"Integration Testing","text":"<p>Create a simple test to verify your integration:</p> <pre><code># test_integration.py\nimport asyncio\nimport pytest\nfrom httpx import AsyncClient\nfrom main import app, agent\n\n@pytest.mark.asyncio\nasync def test_agent_integration():\n    \"\"\"Test that the agent properly handles events and metrics.\"\"\"\n\n    # Start the agent\n    await agent.start()\n\n    try:\n        async with AsyncClient(app=app, base_url=\"http://test\") as client:\n            # Make a normal request\n            response = await client.get(\"/\")\n            assert response.status_code == 200\n\n            # Make an error request\n            response = await client.get(\"/error\")\n            assert response.status_code == 400\n\n            # Check agent status\n            response = await client.get(\"/agent/status\")\n            assert response.status_code == 200\n\n            status = response.json()\n            assert status[\"agent_status\"] == \"running\"\n            assert status[\"events_sent\"] &gt;= 0\n            assert status[\"metrics_sent\"] &gt;= 0\n\n    finally:\n        # Stop the agent\n        await agent.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(test_agent_integration())\n</code></pre>"},{"location":"tutorial/getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic integration working, you can:</p> <ol> <li>Configure Advanced Options - Learn about all configuration options</li> <li>Set up Redis Integration - Add persistent buffering</li> <li>Explore Full Integration - Complete FastAPI Guard integration</li> <li>Monitor &amp; Troubleshoot - Set up monitoring and alerting</li> </ol>"},{"location":"tutorial/getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorial/getting-started/#agent-not-starting","title":"Agent Not Starting","text":"<p>If the agent fails to start:</p> <ol> <li> <p>Check your API credentials:    <pre><code># Test configuration\nconfig = AgentConfig(api_key=\"test\", project_id=\"test\")\nprint(f\"Config valid: {config}\")\n</code></pre></p> </li> <li> <p>Verify network connectivity:    <pre><code>curl -I https://api.fastapi-guard.com/health\n</code></pre></p> </li> <li> <p>Check logs for detailed error messages</p> </li> </ol>"},{"location":"tutorial/getting-started/#events-not-being-sent","title":"Events Not Being Sent","text":"<p>If events aren't reaching the backend:</p> <ol> <li>Check buffer configuration: Lower <code>buffer_size</code> and <code>flush_interval</code> for testing</li> <li>Verify agent status: Use the <code>/agent/status</code> endpoint</li> <li>Check network connectivity and firewall settings</li> </ol>"},{"location":"tutorial/getting-started/#performance-issues","title":"Performance Issues","text":"<p>If the agent impacts performance:</p> <ol> <li>Increase buffer size to reduce HTTP requests</li> <li>Increase flush interval for less frequent transmissions</li> <li>Use Redis for persistent buffering to reduce memory usage</li> <li>Monitor response times and adjust configuration accordingly</li> </ol> <p>Need more help? Check our Troubleshooting Guide or create an issue.</p>"}]}